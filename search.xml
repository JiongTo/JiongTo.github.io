<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web安全</title>
      <link href="/posts/def64e49.html"/>
      <url>/posts/def64e49.html</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-我的安全世界观"><a href="#第1章-我的安全世界观" class="headerlink" title="第1章 我的安全世界观"></a>第1章 我的安全世界观</h1><h2 id="1-1-返璞归真，揭幕安全的本质"><a href="#1-1-返璞归真，揭幕安全的本质" class="headerlink" title="1.1  返璞归真，揭幕安全的本质"></a>1.1  返璞归真，揭幕安全的本质</h2><p> 安全问题的本质是信任的问题。</p><p><strong>安全三要素：</strong>机密性，完整性，可用性。</p><p><strong>机密性</strong>要求保护数据内容不能泄露，加密是实现机密性要求的常见手段。</p><p><strong>完整性</strong>则要求保护数据内容是完整、没有被篡改的。常见的保证一致性的技术手段是数字签名。</p><p><strong>可用性</strong>要求保护资源是“随需而得”。</p><p>在安全领域中，最基本的要素就是这三个，后来还有人想扩充这些要素，增加了诸如<strong>可审计性</strong>、<strong>不可抵赖性</strong>等，但最最重要的还是以上三个要素。在设计安全方案时，也要以这三个要素为基本的出分点，去全面地思考所面对的问题。</p><h2 id="1-2-如何实施安全评估"><a href="#1-2-如何实施安全评估" class="headerlink" title="1.2  如何实施安全评估"></a>1.2  如何实施安全评估</h2><p>有了前面的基础，我们就可以正式开始分析并解决安全问题了。一个安全评估的过程，可以简单地分为4个阶段：资产等级划分、威胁分析、风险分析、确认解决方案。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/08/02/YaE6miUBCLFf5Nq.png" alt="安全评估过程"></p><h3 id="1-2-1-资产等级划分"><a href="#1-2-1-资产等级划分" class="headerlink" title="1.2.1  资产等级划分"></a>1.2.1  资产等级划分</h3><p>资产等级划分是所有工作的基础，这项工作能够帮助我们明确目标是什么，要保护什么。</p><p><strong>互联网安全的核心问题，是数据安全的问题。</strong></p><p>当完成资产等级划分后，对要保护的目标已经有了一个大概的了解，接下来就是要划分信任域和信任边界了。通常我们用一种最简单的划分方式，就是从网络逻辑上来划分。比如最重要的数据放在数据库里，那么把数据库的服务器圈起来；Web应用可以从数据库中读/写数据，并对外提供服务，那再把Web服务器圈起来；最外面是不可信任的 Internet。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/08/02/Q4jiXmsolaqApRw.png" alt="简单网站信任模型"></p><h3 id="1-2-2-威胁分析"><a href="#1-2-2-威胁分析" class="headerlink" title="1.2.2  威胁分析"></a>1.2.2  威胁分析</h3><p>信任域划好之后，我们如何才能确定危险来自哪里呢？在安全领域里，我们把可能造成危害的来源称为威胁(Threat)，而把可能会出现的损失称为风险(Risk)。</p><p>在本书中介绍一种威胁建模的方法，它最早是由微软提出的，叫做STRIDE模型。<br>​STRIDE是6个单词的首字母缩写，我们在分析威胁时，可以从以下6个方面去考虑。</p><table><thead><tr><th align="left">威胁</th><th>定义</th><th>对应的安全属性</th></tr></thead><tbody><tr><td align="left">Spoofing（伪装）</td><td>冒充他人身份</td><td>认证</td></tr><tr><td align="left">Tampering（篡改）</td><td>修改数据或代码</td><td>完整性</td></tr><tr><td align="left">Repudiation（抵赖）</td><td>否认做过的事情</td><td>不可抵赖性</td></tr><tr><td align="left">InformationDisclosure（信息泄露）</td><td>机密信息泄露</td><td>机密性</td></tr><tr><td align="left">Denial of Service（拒绝服务）</td><td>拒绝服务</td><td>可用性</td></tr><tr><td align="left">Elevation of Privilege（提升权限</td><td>未经授权获得许可</td><td>授权</td></tr></tbody></table><h3 id="1-2-3-风险分析"><a href="#1-2-3-风险分析" class="headerlink" title="1.2.3  风险分析"></a>1.2.3  风险分析</h3><p>风险由以下因素组成：</p><p><strong>Risk =  Probability * Damage Potential</strong></p><p>影响风险高低的因素，除了造成损失的大小外，还需要考虑到发生的可能性。地震的危害很大，但是地震、火山活动一般是在大陆板块边缘频繁出现，比如日本、印尼就处于这些地理位置，因此地震频发；而在大陆板块中心，若是地质结构以整块的岩石为主，则不太容易发生地震，因此地震的风险就要小很多。我们在考虑安全问题时，要结合具体情况，权衡事件发生的可能性，才能正确地判断出风险。<br>    如何更科学地衡量风险呢？这里再介绍一个DREAD模型，它也是由微软提出的。DREAD也是几个单词的首字母缩写，它指导我们应该从哪些方面去判断一个威胁的风险程度。</p><table><thead><tr><th>等级</th><th>高(3)</th><th>中(2)</th><th>低(1)</th></tr></thead><tbody><tr><td>Damage Potential</td><td>获取完全验证权限：执行管理员操泄露敏感信息泄露其他信息作；非法上传文件</td><td>泄露敏感信息</td><td>泄露其他信息</td></tr><tr><td>Reproducibility</td><td>攻击者可以随意再次攻击</td><td>攻击者可以重复攻击，但有时间限制</td><td>攻击者很难重复攻击过程</td></tr><tr><td>Exploitability</td><td>初学者在短期内能掌握攻击方法</td><td>熟练的攻击者才能完成这次攻击</td><td>漏洞利用条件非常苛刻</td></tr><tr><td>Affected users</td><td>所有用户，默认配置，关键用户</td><td>部分用户，非默认配置</td><td>极少数用户，匿名用户</td></tr><tr><td>Discoverability</td><td>漏洞很显眼，攻击条件很容易获得</td><td>在私有区域，部分人能看到，需要深入挖掘漏洞</td><td>发现该漏洞极其困难</td></tr></tbody></table><p>在DREAD模型里，每一个因素都可以分为高、中、低三个等级。在上表中，高、中、低三个等级分别以3、2、1 的分数代表其权重值，因此，我们可以具体计算出某一个威胁的风险值。</p><h3 id="1-2-4-设计安全方案"><a href="#1-2-4-设计安全方案" class="headerlink" title="1.2.4  设计安全方案"></a>1.2.4  设计安全方案</h3><p>好的安全产品或模块除了要兼顾用户体验外，还要易于持续改进。一个好的安全模块，同时也应该是一个优秀的程序，从设计上也需要做到高聚合、低耦合、易于扩展。比如 Nmap 的用户就可以自己根据需要写插件，实现一些更为复杂的功能，满足个性化需求。</p><p>最终，一个优秀的安全方案应该具备以下特点：</p><ul><li>能够有效解决问题；</li><li>用户体验好；</li><li>高性能；</li><li>低耦合；</li><li>易于扩展与升级。</li></ul><h2 id="1-3-白帽子兵法"><a href="#1-3-白帽子兵法" class="headerlink" title="1.3  白帽子兵法"></a>1.3  白帽子兵法</h2><h3 id="1-3-1-Secure-By-Default-原则"><a href="#1-3-1-Secure-By-Default-原则" class="headerlink" title="1.3.1  Secure By Default 原则"></a>1.3.1  Secure By Default 原则</h3><p>在设计安全方案时，最基本也最重要的原则就是“Secureby Default”。在做任何安全设计时，都要牢牢记住这个原则。一个方案设计得是否足够安全， 与有没有应用这个原则有很大的关系。实际上，“Secure by Default”原则，也可以归纳为白名单、黑名单的思想。如果更多地使用白名单，那么系统就会变得更安全。</p><h4 id="1-3-1-1-黑名单，白名单"><a href="#1-3-1-1-黑名单，白名单" class="headerlink" title="1.3.1.1 黑名单，白名单"></a>1.3.1.1 黑名单，白名单</h4><p>比如，在制定防火墙的网络访问控制策略时，如果网站只提供Web服务，那么正确的做法是只允许网站服务器的 80 和 443 端口对外提供服务，屏蔽除此之外的其他端口。这是一种“白名单”的做法；如果使用“黑名单”，则可能会出现问题。假设黑名单的策略是：不允许 SSH端口对 Internet开放，那么就要审计 SSH的默认端口：22端口是否开放了Internet。但在实际工作过程中，经常会发现有的工程师为了偷懒或图方便，私自改变了SSH的监听端口，比如把SSH的端口从22改到了2222，从而绕过了安全策略。</p><p>然而，并不是用了白名单就一定安全了。有朋友可能会问，作者刚才讲到选择白名单的思想会更安全，现在又说不一定，这不是自相矛盾吗？我们可以仔细分析一下白名单思想的本质。在前文中提到：“安全问题的本质是信任问题，安全方案也是基于信任来做的”。选择白名单的思想，基于白名单来设计安全方案，其实就是信任白名单是好的，是安全的。但是一旦这个信任基础不存在了，那么安全就荡然无存。</p><h4 id="1-3-1-2-最小权限原则"><a href="#1-3-1-2-最小权限原则" class="headerlink" title="1.3.1.2  最小权限原则"></a>1.3.1.2  最小权限原则</h4><p>Secure By Default的另一层含义就是 “最小权限原则”。 最小权限原则也是安全设计的基本原则之一。 最小权限原则要求系统只授予主体必要的权限，而不要过度授权， 这样能有效地减少系统、网络、应用、数据库出错的机会。</p><h3 id="1-3-2-纵深防御原则"><a href="#1-3-2-纵深防御原则" class="headerlink" title="1.3.2  纵深防御原则"></a>1.3.2  纵深防御原则</h3><p>与 Secure by Default一样，Defense in Depth（纵深防御）也是设计安全方案时的重要指导思想。</p><p>纵深防御包含两层含义：首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；其次，要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。</p><p>纵深防御并不是同一个安全方案要做两遍或多遍，而是要从不同的层面、不同的角度对系统做出整体的解决方案。我们常常听到“木桶理论”这个词，说的是一个桶能装多少水，不是取决于最长的那块板，而是取决于最短的那块板，也就是短板。设计安全方案时最怕出现短板，木桶的一块块板子，就是各种具有不同作用的安全方案，这些板子要紧密地结合在一起，才能组成一个不漏水的木桶。</p><blockquote><p>在常见的入侵案例中，大多数是利用Web 应用的漏洞，攻击者先获得一个低权限的webshell,然后通过低权限的webshell 上传更多的文件， 并尝试执行更高权限的系统命令，尝试在服务器上提升权限为root;接下来攻击者再进一步尝试渗透内网， 比如数据库服务器所在的网段。</p><p>在这类入侵案例中，如果在攻击过程中的任何一个环节 设置有效的防御措施，都有可能导致入侵过程功亏一篑。 但是世上没有万能灵药， 也没有哪种解决方案能解决所有问题，因此非常有必要将风险分散到系统的各个层面。就入侵的防御来说，我们需要考虑的可能有Web应用安全、OS系统安全、数据库安全、网络环境安全等。在这些不同层面设计的安全方案，将共同组成整个防御体系，这也就是纵深防御的思想。</p></blockquote><p>纵深防御的第二二层含义，是要在正确的地方做正确的事情。如何理解呢？它要求我们深入理解威胁的本质，从而做出正确的应对措施。</p><blockquote><p>在 XSS防御技术的发展过程中，曾经出现过几种不同的解决思路，直到最近几年 XSS 的防御思路才逐渐成熟和统一。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2024/08/02/b4Rravd316ZhBQp.png" alt="XSS防御技术的发展过程"></p><p>在一开始的方案中，主要是过滤一些特殊字符，比如：</p><p>&lt;&lt;笑傲江湖&gt;&gt;  会变成  笑傲江湖</p><p>尖括号被过滤掉了。</p><p>但是这种粗暴的做法常常会改变用户原本想表达的意思，比如：</p><p>1&lt;2  可能会变成  12</p><p>造成这种“乌龙”的结果就是因为没有“在正确的地方做正确的事情”。对于XSS防御，对系统取得的用户输入进行过滤其实是不太合适的，因为XSS真正产生危害的场景是在用户的浏览器上，或者说服务器端输出的 HTML 页面，被注入了恶意代码。只有在拼装HTML 时输出，系统才能获得HTML上下文的语义，才能判断出是否存在误杀等情况。所以“在正确的地方做正确的事情”，也是纵深防御的一种含义必须把防御方案放到最合适的地方去解决。(XSS防御的更多细节请参考“跨站脚本攻击”一章。)</p></blockquote><p>对于一个复杂的系统来说，纵深防御是构建安全体系的必要选择。</p><h3 id="1-3-3-数据与代码分离原则"><a href="#1-3-3-数据与代码分离原则" class="headerlink" title="1.3.3  数据与代码分离原则"></a>1.3.3  数据与代码分离原则</h3><p>另一个重要的安全原则是数据与代码分离原则。这一原则广泛适用于各种由于“注入”而引发安全问题的场景。</p><p>实际上，缓冲区溢出，也可以认为是程序违背了这一原则的后果——程序在栈或者堆中，将用户数据当做代码执行，混淆了代码与数据的边界，从而导致安全问题的发生。</p><blockquote><p>在Web安全中，由“注入”引起的问题比比皆是， 如XSS、SQLInjection、CRLF Injection、X-Path Injection等。此类问题均可以根据 “数据与代码分离原则”设计出真正安全的解决方案，因为这个原则抓住了漏洞形成的本质原因。</p><p>以XSS为例，它产生的原因是HTMLInjection或JavaScript Injection,如果一个页面的代码如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>$var<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 $var 是用户能够控制的变量，那么对于这段代码来说：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就是程序的代码执行段。</p><p>而</p><pre class="line-numbers language-none"><code class="language-none">$var<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是程序的用户数据片段。</p><p>如果把用户数据片段 $var 当成代码片段来解释、执行，就会引发安全问题。</p><p>比如，当$var 的值是：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>http://evil</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>时，用户数据就被注入到代码片段中。解析这段脚本并执行的过程，是由浏览器来完成的浏览器将用户数据里的<script>标签当做代码来解释一这显然不是程序开发者的本意。</p><p>根据数据与代码分离原则，在这里应该对用户数据片段$var进行安全处理，可以使用过滤、编码等手段，把可能造成代码混淆的用户数据清理掉，具体到这个案例中，就是针对<、> 等符号做处理。有的朋友可能会问了：我这里就是要执行一个<script>标签，要弹出一段文字，比如：“你好！”，那怎么办呢？在这种情况下，数据与代码的情况就发生了变化，根据数据与代码分离原则，我们就应该重写代码片段：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"$var1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，<script>标签也变成了代码片段的一部分， 用户数据只有$varl 能够控制，从而杜绝了安全问题的发生。</p></blockquote><h3 id="1-3-4-不可预测原则"><a href="#1-3-4-不可预测原则" class="headerlink" title="1.3.4  不可预测原则"></a>1.3.4  不可预测原则</h3><p>前面介绍的几条原则： Secure By Default,是时刻要牢记的总则；纵深防御，是要更全面、更正确地看待问题；数据与代码分离，是从漏洞成因上看问题：接下来要讲的“不可预测性”原则，则是从克服攻击方法的角度看问题。</p><blockquote><p>微软的Windows 系统用户多年来深受缓冲区溢出之苦， 因此微软在Windows的新版本中增加了许多对抗缓冲区溢出等内存攻击的功能。 微软无法要求运行在系统中的软件没有漏洞，因此它采取的做法是让漏洞的攻击方法失效。 比如，使用DEP来保证堆栈不可执行，使用 ASLR让进程的栈基址随机变化， 从而使攻击程序无法准确地猜测到内存地址， 大大提高了攻击的门槛。经过实践检验， 证明微软的这个思路确实是有效的即使无法修复code，但是如果能够使得攻击的方法无效， 那么也可以算是成功的防御。</p><p>微软使用的ASLR技术，在较新版本的Linux 内核中也支持。在ASLR的控制下，一个程序每次启动时，其进程的栈基址都不相同， 具有一定的随机性，对于攻击者来说，这就是 “不可预测性”。</p></blockquote><p>不可预测性(Unpredictable), 能有效地对抗基于篡改、伪造的攻击。 </p><blockquote><p>我们看看如下场景：假设一个内容管理系统中的文章序号， 是按照数字升序排列的，比如id=1000, id=1002,id=1003.*...这样的顺序，使得攻击者能够很方便地遍历出系统中的所有文章编号：找到一个整数，依次递增即可。 如果攻击者想要批量删除这些文章， 写个简单的脚本：</p><pre class="line-numbers language-none"><code class="language-none">for (i&#x3D;0;i&lt;100000;i++)&#123;  Delete(url+&quot;?id&#x3D;&quot;+i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就可以很方便地达到目的。 但是如果该内容管理系统使用了 “不可预测性”原则，将id的值变得不可预测，会产生什么结果呢？</p><p>id=asldfjaefsadlf, id=adsfalkennffxc, id=poerjfweknfd....</p><p>id的值变得完全不可预测了， 攻击者再想批量删除文章，只能通过爬虫把所有的页面id全部抓取下来，再一一进行分析， 从而提高了攻击的门槛。</p></blockquote><p>不可预测性原则， 可以巧妙地用在一些敏感数据上。比如在 CSRF的防御技术中，通常会使用一个token来进行有效防御。这个token 能成功防御CSRF，就是因为攻击者在实施 CSRF攻击的过程中，是无法提前预知这个token 值的，因此要求token足够复杂时， 不能被攻击者猜测到。(具体细节请参考“跨站点请求伪造” 一章。)</p><p>不可预测性的实现往往需要用到加密算法、 随机数算法、哈希算法， 好好使用这条原则，在设计安全方案时往往会事半功倍。</p><h1 id="第2章-浏览器安全"><a href="#第2章-浏览器安全" class="headerlink" title="第2章  浏览器安全"></a>第2章  浏览器安全</h1><h2 id="2-1-同源策略"><a href="#2-1-同源策略" class="headerlink" title="2.1  同源策略"></a>2.1  同源策略</h2><p><strong>浏览器的同源策略，限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。</strong></p><blockquote><p>这一策略极其重要，试想如果没有同源策略，可能 a.com 的一段JavaScript 脚本，在 b.com未曾加载此脚本时，也可以随意涂改 b.com 的页面（在浏览器的显示中）。为了不让浏览器的页面行为发生混乱，浏览器提出了“Origin”（源）这一概念，来自不同 Origin 的对象无法互相干扰。</p></blockquote><p>对于JavaScript来说，以下情况被认为是同源与不同源的。</p><table><thead><tr><th>URL</th><th>Outcome</th><th>Reason</th></tr></thead><tbody><tr><td>http: //store.company.com/dir2/other.html</td><td>Success</td><td></td></tr><tr><td><a class="link"   href="http://store.company.com/dir/inner/another.html" >http://store.company.com/dir/inner/another.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td>Success</td><td></td></tr><tr><td><a class="link"   href="https://store/" >https://store <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> .company.com/secure.html</td><td>Failure</td><td>Different protocol</td></tr><tr><td><a class="link"   href="http://store.company.com:81/dir/etc.html" >http://store.company.com:81/dir/etc.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td>Failure</td><td>Different port</td></tr><tr><td><a class="link"   href="http://news.company.com/dir/other.html" >http://news.company.com/dir/other.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td><td>Failure</td><td>Different host</td></tr></tbody></table><p>由上表可以看出，影响“源”的因素有：host(域名或IP地址，如果是IP地址则看做一个根域名）、子域名、端口、协议。</p><p>需要注意的是，对于当前页面来说，页面内存放 JavaScript 文件的域并不重要，重要的是加载 JavaScript 页面所在的域是什么。</p><p>换言之，a.com 通过以下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>http://b.com/b.js</span> <span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加载了 b.com上的 b.js，但是 b.js 是运行在 a.com 页面中的，因此对于当前打开的页面（a.com页面）来说，b.js 的 Origin 就应该是 a.com 而非 b.com.在浏览器中，<script>、<img>、<iframe>、<link>等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次 GET 请求。不同于 XMLHttpRequest 的是，通过 src 属性加载的资源，浏览器限制了JavaScript 的权限，使其不能读、写返回的内容。</p><p>对于 XMLHttpRequest 来说，它可以访问来自同源对象的内容。但 XMLHttpRequest 受到同源策略的约束，不能跨域访问资源，在 AJAX 应用的开发中尤其需要注意这一点。</p><p>如果XMLHttpRequest 能够跨域访问资源，则可能会导致一些敏感数据泄露，比如 CSRF的token，从而导致发生安全问题。</p><p>但是互联网是开放的，随着业务的发展，跨域请求的需求越来越迫切，因此 W3C 委员会制定了 XMLHttpRequest 跨域访问标准。它需要通过目标域返回的 HTTP 头来授权是否允许跨域访问，因为HTTP头对于JavaScript 来说一般是无法控制的，所以认为这个方案可以实施。注意：这个跨域访问方案的安全基础就是信任“JavaScript 无法控制该HTTP 头”，如果此信任基础被打破，则此方案也将不再安全。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/02/FGJkEBWvrShxlmn.png"                      alt="跨域访问请求过程"                ></p><p>对于浏览器来说，除了 DOM、Cookie、XMLHttpRequest 会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。最常见的一些插件如 Flash、Java Applet、Silverlight、Google Gears 等都有自己的控制策略。</p><blockquote><p>以Flash为例，它主要通过目标网站提供的crossdomain.xml 文件判断是否允许当前“源”的Flash跨域访问目标资源。</p><p>以<a class="link"   href="http://www.qq.com/" >www.qq.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的策略文件为例，当浏览器在任意其他域的页面里加载了 Flash 后，如果对 <a class="link"   href="http://www.qq.com/" >www.qq.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 发起访问请求，Flash 会先检查 <a class="link"   href="http://www.qq.com/" >www.qq.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上此策略文件是否存在。如果文件存在，则检查发起请求的域是否在许可范围内。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2024/08/02/uloq73PjcgfIdNe.png"                      alt="www.qq.com的crossdomain.xml文件"                ></p><p>在这个策略文件中，只有来自*.qq.com 和*.gtimg.com域的请求是被允许的。依靠这种方式，从Origin的层面上控制了Flash行为的安全性。</p></blockquote><p>我们前面提到，比如<script>等标签仅能加载资源，但不能读、写资源的内容，而这个漏洞能够跨域读取页面内容，因此绕过了同源策略，成为个跨域漏洞。</p><p>浏览器的同源策略是浏览器安全的基础，在本书后续章节中提到的许多客户端脚本攻击，都需要遵守这一法则，因此理解同源策略对于客户端脚本攻击有着重要意义。同源策略一旦出现漏洞被绕过，也将带来非常严重的后果，很多基于同源策略制定的安全方案都将失去效果。</p><h2 id="2-2-浏览器沙盒"><a href="#2-2-浏览器沙盒" class="headerlink" title="2.2  浏览器沙盒"></a>2.2  浏览器沙盒</h2><p>在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被形象地称为“挂马”。</p><p>“挂马”是浏览器需要面对的一个主要威胁。近年来，独立于杀毒软件之外，浏览器厂商根据挂马的特点研究出了一些对抗挂马的技术。</p><p>比如在 Windows 系统中，浏览器密切结合 DEP、ASLR、SafeSEH 等操作系统提供的保护技术，对抗内存攻击。与此同时，浏览器还发展出了多进程架构，从安全性上有了很大的提高。浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。</p><p>Google Chrome 是第一个采取多进程架构的浏览器。Google Chrome 的主要进程分为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程如 flash、java、pdf 等与浏览器进程严格隔离，因此不会互相影响。</p><p>渲染引擎由 Sandbox 隔离，网页代码要与浏览器内核进程通信、与操作系统通信都需要通过 IPC channel，在其中会进行一些安全检查。</p><p>Sandbox即沙箱，计算机技术发展到今天，Sandbox已经成为泛指“资源隔离类模块”的代名词。Sandbox 的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。如果一定要跨越 Sandbox 边界产生数据交换，则只能通过指定的数据通道，比如经过封装的 API来完成，在这些 API中会严格检查请求的合法性。</p><p>Sandbox 的应用范围非常广泛。比如一个提供 hosting 服务的共享主机环境，假设支持用户上传 PHP、Python、Java 等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个 Sandbox 对用户代码进行隔离。Sandbox 需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p><p>而对于浏览器来说，采用 Sandbox 技术，无疑可以让不受信任的网页代码、JavaScript 代码运行在一个受到限制的环境中，从而保护本地桌面系统的安全。</p><h2 id="2-3-恶意网站拦截"><a href="#2-3-恶意网站拦截" class="headerlink" title="2.3  恶意网站拦截"></a>2.3  恶意网站拦截</h2><p>上节提到了“挂马”攻击方式能够破坏浏览器安全， 在很多时候，“挂马”攻击在实施时会在一个正常的网页中通过<script>或者<iframe>等标签加载一个恶意网址。 而除了挂马所加载的恶意网址之外，钓鱼网站、诈骗网站对于用户来 说也是一种恶意网址。为了保护用户安全，浏览器厂商纷纷推出 了各自的拦截恶意网址功能。目前各个浏览器的拦截恶意网址的功能都是基于“黑名单”的。</p><p>恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务 器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中， 浏览器就会弹出一个警告页面。</p><p>常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含有恶意的脚本如JavaScript或Flash, 通过利用浏览器的漏洞(包括一些插件、控件漏洞)执行shellcode, 在用户电脑中植入木马：另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。</p><p>除了恶意网址黑名单拦截功能外， 主流浏览器都开始支持EVSSL证 书（Extended ValidationSSLCertificate)，以增强对安全网站的识别。</p><p>EVSSL 证书是全球数字证书颁发机构与浏览器厂商一起打造的增强型证书，其主要特色是浏览器会给予EVSSL证书特殊待遇。 EVSSL 证书也遵循X509标准，并向前兼容普通证书。如果浏览器不支持EV模式， 则会把该证书当做普通证书；如果浏览器支持 (需要较新版本的浏览器）EV模式，则会在地址栏中特别标注。</p><p>因此网站在使用了EV SSL证书后，可以教育用户识别真实网站在浏览器地址栏中的“绿色”表现，以对抗钓鱼网站。</p><h2 id="2-4-高速发展的浏览器安全"><a href="#2-4-高速发展的浏览器安全" class="headerlink" title="2.4  高速发展的浏览器安全"></a>2.4  高速发展的浏览器安全</h2><p>为了在安全领域获得竞争力，微软率先在IE8中推出了XSS Filter 功能，用以对抗反射型XSS。一直以来，XSS（跨站脚本攻击）都被认为是服务器端应用的漏洞，应该由服务器端应用在代码中修补，而微软率先推出了这一功能，就使得IE8在安全领域极具特色。</p><p>当用户访问的URL中包含了XSS攻击的脚本时，IE就会修改其中的关键字符使得攻击无法成功完成，并对用户弹出提示框。</p><p>而 Firefox 也不甘其后，在 Firefox 4 中推出了 Content Security Policy(CSP)。这一策略是由安全专家 Robert Hanson 最早提出的，其做法是由服务器端返回一个 HTTP 头，并在其中描述页面应该遵守的安全策略。</p><p>由于XSS攻击在没有第三方插件帮助的情况下，无法控制HTTP 头，所以这项措施是可行的。</p><p>而这种自定义的语法必须由浏览器支持并实现，Firefox是第一个支持此标准的浏览器。使用CSP 的方法如下，插入一个HTTP 返回头：</p><pre class="line-numbers language-none"><code class="language-none">X-Content-Security-Policy: policy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 policy 的描述极其灵活，比如：</p><pre class="line-numbers language-none"><code class="language-none">X-Content-Security-Policy: allow &#39;self&#39; *.mydomain.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器将信任来自 mydomain.com 及其子域下的内容。</p><p>又如：</p><pre class="line-numbers language-none"><code class="language-none">X-Content-Security-Policy: allow &#39;self&#39;; img-src *; media-src medial.com; script-srcuserscripts.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器除了信任自身的来源外，还可以加载任意域的图片、来自 medial.com 的媒体文件，以及 userscripts.example.com 的脚本，其他的则一律拒绝。</p><p>CSP的设计理念无疑是出色的，但是CSP的规则配置较为复杂，在页面较多的情况下，很准一个个配置起来，且后期维护成本也非常巨大，这些原因导致CSP未能得到很好的推广。</p><p>扩展和插件极大地丰富了浏览器的功能，但安全问题也随之而来，除了插件可能存在漏洞外，插件本身也可能会有恶意行为。扩展和插件的权限都高于页面JavaScript的权限，比如可以进行一些跨域网络请求等。</p><h1 id="第3章-跨站脚本攻击（XSS）"><a href="#第3章-跨站脚本攻击（XSS）" class="headerlink" title="第3章 跨站脚本攻击（XSS）"></a>第3章 跨站脚本攻击（XSS）</h1></script></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python知识点</title>
      <link href="/posts/2ff10834.html"/>
      <url>/posts/2ff10834.html</url>
      
        <content type="html"><![CDATA[<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>Python中，标识符命名的规则主要有3类：</p><ul><li>内容限定</li><li>大小写敏感</li><li>不可使用关键字</li></ul><h5 id="标识符命名规则-内容限定"><a href="#标识符命名规则-内容限定" class="headerlink" title="标识符命名规则 - 内容限定"></a>标识符命名规则 - 内容限定</h5><p>标识符命名中，只允许出现：</p><ul><li><p>英文</p></li><li><p>中文</p></li><li><p>数字</p></li><li><p>下划线(_)</p></li></ul><p>不能用数字开头</p><p>其余任何内容都不被允许。</p><h5 id="标识符命名规则-大小写敏感"><a href="#标识符命名规则-大小写敏感" class="headerlink" title="标识符命名规则 - 大小写敏感"></a>标识符命名规则 - 大小写敏感</h5><h5 id="标识符命名规则-不可以使用关键字"><a href="#标识符命名规则-不可以使用关键字" class="headerlink" title="标识符命名规则 -不可以使用关键字"></a>标识符命名规则 -不可以使用关键字</h5>]]></content>
      
      
      <categories>
          
          <category> 知识整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo指令</title>
      <link href="/posts/89e11d40.html"/>
      <url>/posts/89e11d40.html</url>
      
        <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo init [folder]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a class="link" href="https://github.com/hexojs/hexo-starter">hexo-starter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link" href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 主题到当前目录或指定目录。</li><li>使用 <a class="link" href="https://classic.yarnpkg.com/lang/en/">Yarn 1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link" href="https://pnpm.io/zh/">pnpm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或 <a class="link" href="https://docs.npmjs.com/cli/install">npm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a class="link" href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Node-js">Node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo new [layout] &lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a class="link" href="https://hexo.io/zh-cn/docs/configuration">_config.yml <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre class="line-numbers language-none"><code class="language-none">$ hexo new "post title with whitespace"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre class="line-numbers language-none"><code class="language-none">hexo new page --path about/me "About me"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre class="line-numbers language-none"><code class="language-none">hexo new page --path about/me<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre class="line-numbers language-none"><code class="language-none">$ hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo publish [layout] &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre class="line-numbers language-none"><code class="language-none">$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre class="line-numbers language-none"><code class="language-none">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>如果更新博客文章后，个人备份指令</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit-m“更新事项”git pushhexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA</title>
      <link href="/posts/498f0b66.html"/>
      <url>/posts/498f0b66.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-JAVA的基础概念"><a href="#1-JAVA的基础概念" class="headerlink" title="1.JAVA的基础概念"></a>1.JAVA的基础概念</h3><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>作用：</p><p> 如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。</p><p> 在启动软件的时候，操作系统会先在当前路径下找，如果在当前录课没有再到环境变量的路径中去找。如果都找不到就提示无法启动。</p><h5 id="JDK的安装目录介绍"><a href="#JDK的安装目录介绍" class="headerlink" title="JDK的安装目录介绍"></a>JDK的安装目录介绍</h5><table><thead><tr><th align="left">目录名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">bin</td><td align="left">该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。</td></tr><tr><td align="left">conf</td><td align="left">该路径下存放了JDK的相关配置文件。</td></tr><tr><td align="left">include</td><td align="left">该路径下存放了一些平台特定的头文件。</td></tr><tr><td align="left">jmods</td><td align="left">该路径下存放了JDK的各种模块。</td></tr><tr><td align="left">legal</td><td align="left">该路径下存放了JDK各模块的授权文档。</td></tr><tr><td align="left">lib</td><td align="left">该路径下存放了JDK工具的一些补充JAR包。</td></tr></tbody></table><h5 id="Java的三大平台"><a href="#Java的三大平台" class="headerlink" title="Java的三大平台"></a>Java的三大平台</h5><p> JavaSE、JavaME、JavaEE</p><p>JavaSE</p><p> 是其他两个版本的基础。</p><p>JavaME</p><p> Java语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p><p> 其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p><p> 但是，安卓也是可以用Java来开发的。</p><p>JavaEE</p><p> 用于Web方向的网站开发。（主要从事后台服务器的开发）</p><p> 在服务器领域，Java是当之无愧的龙头老大。</p><h5 id="Java的主要特性"><a href="#Java的主要特性" class="headerlink" title="Java的主要特性"></a>Java的主要特性</h5><ul><li>面向对象</li><li>安全性</li><li>多线程</li><li>简单易用</li><li>开源</li><li>跨平台</li></ul><h5 id="Java语言跨平台的原理"><a href="#Java语言跨平台的原理" class="headerlink" title="Java语言跨平台的原理"></a>Java语言跨平台的原理</h5><ul><li>操作系统本身其实是不认识Java语言的。</li><li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li></ul><p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/16/PdJbHQEuMxtZLaq.png" alt="img"></p><h5 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h5><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/16/6e1wviyUlRScTWj.png" alt="img"></p><p>JVM（Java Virtual Machine），Java虚拟机</p><p>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</p><p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p><p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p><h5 id="基本数据类型的四类八种"><a href="#基本数据类型的四类八种" class="headerlink" title="基本数据类型的四类八种"></a>基本数据类型的四类八种</h5><table><thead><tr><th align="left">数据类型</th><th align="left">关键字</th><th align="left">内存占用</th><th align="left">取值范围</th></tr></thead><tbody><tr><td align="left">整数</td><td align="left">byte</td><td align="left">1</td><td align="left">负的2的7次方 ~ 2的7次方-1(-128~127)</td></tr><tr><td align="left"></td><td align="left">short</td><td align="left">2</td><td align="left">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td></tr><tr><td align="left"></td><td align="left">int</td><td align="left">4</td><td align="left">负的2的31次方 ~ 2的31次方-1</td></tr><tr><td align="left"></td><td align="left">long</td><td align="left">8</td><td align="left">负的2的63次方 ~ 2的63次方-1</td></tr><tr><td align="left">浮点数</td><td align="left">float</td><td align="left">4</td><td align="left">1.401298e-45 ~ 3.402823e+38</td></tr><tr><td align="left"></td><td align="left">double</td><td align="left">8</td><td align="left">4.9000000e-324 ~ 1.797693e+308</td></tr><tr><td align="left">字符</td><td align="left">char</td><td align="left">2</td><td align="left">0-65535</td></tr><tr><td align="left">布尔</td><td align="left">boolean</td><td align="left">1</td><td align="left">true，false</td></tr></tbody></table><p>在java中整数默认是int类型，浮点数默认是double类型。</p><h5 id="需要记忆以下几点"><a href="#需要记忆以下几点" class="headerlink" title="需要记忆以下几点"></a>需要记忆以下几点</h5><p>byte类型的取值范围：</p><p> -128 ~ 127</p><p>int类型的大概取值范围：</p><p> -21亿多 ~ 21亿多</p><p>整数类型和小数类型的取值范围大小关系：</p><p> double &gt; float &gt; long &gt; int &gt; short &gt; byte</p><p>最为常用的数据类型选择：</p><ul><li><p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p><p>比如：人的年龄，可以选择byte类型。</p><p>比如：地球的年龄，可以选择long类型。</p></li><li><p>如果整数类型中，不太确定范围，那么默认使用int类型。</p></li><li><p>如果小数类型中，不太确定范围，那么默认使用double类型。</p></li><li><p>如果要定义字符类型的变量，那么使用char</p></li><li><p>如果要定义布尔类型的变量，那么使用boolean</p></li></ul><h5 id="标识符命名规则-—硬性要求"><a href="#标识符命名规则-—硬性要求" class="headerlink" title="标识符命名规则 —硬性要求"></a>标识符命名规则 —硬性要求</h5><ul><li>必须由数字、字母、下划线_、美元符号$组成。</li><li>数字不能开头</li><li>不能是关键字</li><li>区分大小写的</li></ul><h5 id="小驼峰命名法"><a href="#小驼峰命名法" class="headerlink" title="小驼峰命名法"></a>小驼峰命名法</h5><p>适用于变量名和方法名</p><ul><li>如果是一个单词，那么全部小写，比如：name</li><li>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</li></ul><h5 id="大驼峰命名法"><a href="#大驼峰命名法" class="headerlink" title="大驼峰命名法"></a>大驼峰命名法</h5><p>适用于类名</p><ul><li>如果是一个单词，那么首字母大写。比如：Demo、Test。</li><li>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</li></ul><p>不管起什么名字，都要做到见名知意。</p><h5 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h5><p> 键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</p><p>使用步骤：</p><p>第一步：</p><p> 导包：其实就是表示先找到Scanner这个类在哪。</p><p>第二步：</p><p> 创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</p><p>第三步：</p><p> 接收数据：也是真正干活的代码。</p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//导包，其实就是先找到Scanner这个类在哪</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerDemo1</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span><span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.接收数据</span><span class="token comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入一个数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h5><p><strong>概念：</strong></p><p> 也叫自动类型提升。</p><p> 就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。</p><p><strong>简单记忆：</strong></p><p> 就是小的给大的，可以直接给。</p><p><strong>两种提升规则：</strong></p><ul><li>取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。</li><li>byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。</li></ul><h5 id="取值范围从小到大的关系："><a href="#取值范围从小到大的关系：" class="headerlink" title="取值范围从小到大的关系："></a>取值范围从小到大的关系：</h5><p> byte &lt; short &lt; int &lt; long &lt; float &lt; double</p><h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><p><strong>概念：</strong></p><p> 如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。</p><p> 如果一定要这么干，就需要加入强制转换。</p><p><strong>书写格式：</strong></p><p> 目标数据类型 变量名 = （目标数据类型）被强转的数据；</p><p>简单理解：</p><p> 要转成什么类型的，那么就在小括号中写什么类型就可以了。</p><p>注意点：</p><p> 强制转换有可能会导致数据发生错误。（数据的精度丢失）</p><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><h5 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h5><p>分类： &amp;&amp; ||</p><p><strong>&amp;&amp;：</strong></p><p> 运算结果跟&amp;是一模一样的，只不过具有短路效果。</p><p><strong>||：</strong></p><p> 运算结果跟|是一模一样的。只不过具有短路效果。</p><h5 id="逻辑核心："><a href="#逻辑核心：" class="headerlink" title="逻辑核心："></a>逻辑核心：</h5><p> 当左边不能确定整个表达式的结果，右边才会执行。</p><p> 当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</p><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5><p>又叫做：三元表达式或者问号冒号表达式。</p><p><strong>格式：</strong></p><p> 关系表达式 ？ 表达式1 ：表达式2 ；</p><p><strong>计算规则：</strong></p><ul><li>计算关系表达式的值。</li><li>如果关系表达式的值为真，那么执行表达式1。</li><li>如果关系表达式的值为假，那么执行表达式2。</li></ul><p><strong>注意点：</strong></p><p> 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</p><h3 id="3-判断和循环"><a href="#3-判断和循环" class="headerlink" title="3.判断和循环"></a>3.判断和循环</h3><h5 id="switch的扩展知识："><a href="#switch的扩展知识：" class="headerlink" title="switch的扩展知识："></a>switch的扩展知识：</h5><ul><li><p>default的位置和省略情况</p><p>default可以放在任意位置，也可以省略</p></li><li><p>case穿透</p><p>不写break会引发case穿透现象</p></li><li><p>switch在JDK12的新特性</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"一"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"二"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"其他"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="for循环格式："><a href="#for循环格式：" class="headerlink" title="for循环格式："></a>for循环格式：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>初始化语句<span class="token punctuation">;</span>条件判断语句<span class="token punctuation">;</span>条件控制语句<span class="token punctuation">)</span> <span class="token punctuation">{</span>循环体语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>格式解释：</strong></p><ul><li>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li><li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li><li>循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li><li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li></ul><p><strong>执行流程：</strong></p><p>①执行初始化语句</p><p>②执行条件判断语句，看其结果是true还是false</p><p> 如果是false，循环结束</p><p> 如果是true，继续执行</p><p>③执行循环体语句</p><p>④执行条件控制语句</p><pre class="line-numbers language-none"><code class="language-none">public class Test4 {    public static void main(String[] args) {        int sum = 0;        for (int i = 1;i &lt;= 100;i++){            System.out.println(i);            sum += i;        }        System.out.println(sum);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>扩展小点</strong><br>求和的变量不能定义在循环的里面，因为变量只在所属的大括号中有效<br>如果我们把变量定义在循环的里面，那么当前变量只能在本次循环中有效。<br>当本次循环结束之后，变量就会从内存中消失。<br>第二次循环开始的时候，又会重新定义一个新的变量<br>结论：如果以后我们要写累加求和的变量。可以把变量定义在循环的外面。</p><h5 id="while循环格式："><a href="#while循环格式：" class="headerlink" title="while循环格式："></a>while循环格式：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">初始化语句<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>条件判断语句<span class="token punctuation">)</span><span class="token punctuation">{</span>循环体<span class="token punctuation">;</span>条件控制语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>for和while的区别：</strong></p><ul><li>for循环中，控制循环的变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了。</li><li>while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用。</li><li>for循环中：知道循环次数或者循环的范围</li><li>while循环中：不知道循环次数和范围，只知道循环的结束条件</li></ul><h5 id="do…while循环格式："><a href="#do…while循环格式：" class="headerlink" title="do…while循环格式："></a>do…while循环格式：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">初始化语句<span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span>    循环体<span class="token punctuation">;</span>    条件控制语句<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>条件判断语句<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特点：</p><p> 先执行，再判断。</p><h3 id="4-循环高级和数组"><a href="#4-循环高级和数组" class="headerlink" title="4.循环高级和数组"></a>4.循环高级和数组</h3><p><strong>无限循环</strong></p><p>概念：</p><p> 又叫死循环。循环一直停不下来。</p><p><strong>for</strong>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环执行一直在打印内容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解释：</p><p>初始化语句可以空着不写，表示循环之前不定义任何的控制变量。</p><p>条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。</p><p>条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。</p><p><strong>while</strong>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环执行一直在打印内容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解释：</p><p> 小括号里面就不能省略了，true一定要写出来，否则代码会报错。</p><p><strong>do…while格式：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">do</span><span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"循环执行一直在打印内容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解释：</p><p> 小括号里面就不能省略了，true一定要写出来，否则代码会报错。</p><p><strong>无限循环的注意事项：</strong></p><ul><li>最为常用的格式：while</li><li>无限循环下面不能再写其他代码了，因为永远执行不到。</li></ul><p><strong>条件控制语句</strong></p><ul><li>break</li><li>continue</li></ul><p><strong>break</strong>:</p><p> 不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。</p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.吃1~5号包子</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在吃第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"个包子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2.吃完第三个的时候就不吃了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//结束整个循环。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>continue</strong>:</p><p> 不能单独存在的。只能存在于循环当中。</p><p> 表示：跳过本次循环，继续执行下次循环。</p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.吃1~5号包子</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//2.第3个包子有虫子就跳过，继续吃下面的包子</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在吃第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"个包子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Random</strong></p><p>Random跟Scanner一样，也是Java提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。</p><p><strong>使用步骤：</strong></p><ol><li>导包</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span>导包的动作必须出现在类定义的上边。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>创建对象</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>上面这个格式里面，只有r是变量名，可以变，其他的都不允许变。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>生成随机数</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> number <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>随机数的范围<span class="token punctuation">)</span><span class="token punctuation">;</span>上面这个格式里面，只有number是变量名，可以变，其他的都不允许变。随机数范围的特点：从<span class="token number">0</span>开始，不包含指定值。比如：参数为<span class="token number">10</span>，生成的范围<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.导包</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RandomDemo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//2.创建对象</span>        <span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.生成随机数</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包左不包右，包头不包尾</span>        <span class="token comment">//0 ~ 99</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h5><p><strong>完整格式：</strong></p><p> 数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4…};</p><p>比如：</p><p> int[] arr = new int[]{11,22,33};</p><p> double[] arr = new double[]{1.1,1.2,1.3};</p><p><strong>注意点</strong>：</p><ul><li>等号前后的数据类型必须保持一致。</li><li>数组一旦创建之后，长度不能发生变化。</li></ul><p><strong>简化格式</strong>:</p><p> 数据类型[] 数组名 = {元素1，元素2，元素3，元素4…};</p><p>比如：</p><p> int[] array = {1,2,3,4,5};</p><p> double[] array = {1.1,1.2,1.3};</p><h5 id="地址值"><a href="#地址值" class="headerlink" title="地址值"></a>地址值</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[I@6d03e736</span><span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.1</span><span class="token punctuation">,</span><span class="token number">2.2</span><span class="token punctuation">,</span><span class="token number">3.3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[D@568db2f2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印数组的时候，实际出现的是数组的地址值。</p><p>数组的地址值：就表示数组在内存中的位置。</p><p>以[I@6d03e736为例：</p><p>[ ：表示现在打印的是一个数组。</p><p>I：表示现在打印的数组是int类型的。</p><p>@：仅仅是一个间隔符号而已。</p><p>6d03e736：就是数组在内存中真正的地址值。（十六进制的）</p><p>但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值。</p><h5 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h5><p><strong>格式</strong>：</p><p> 数组名[索引];</p><p><strong>作用</strong>：</p><ul><li><p>获取数组中对应索引上的值</p></li><li><p>修改数组中对应索引上的值</p><p>一旦修改之后，原来的值就会被覆盖了。</p></li></ul><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">     pub  <span class="token comment">/*        数组中元素访问的格式：                数组名[索引];         作用：            1.获取指定索引上对应的元素            2.修改指定索引上对应的元素    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">//需求1：获取arr数组中，3索引上的值</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//需求2：将arr数组中，3索引上的值修改为10</span>            arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改之后为:"</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p> 也叫角标、下标</p><p> 就是数组容器中每一个小格子对应的编号。</p><p>索引的特点：</p><ul><li>索引一定是从0开始的。</li><li>连续不间断。</li><li>逐个+1增长。</li></ul><h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><p>遍历：就是把数组里面所有的内容一个一个全部取出来。</p><p>数组的长度：数组名.length;</p><p>通用代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//在循环的过程中，i依次表示数组中的每一个索引</span>    <span class="token function">sout</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="数组的动态初始化"><a href="#数组的动态初始化" class="headerlink" title="数组的动态初始化"></a>数组的动态初始化</h5><p>格式：</p><p> 数据类型[] 数组名 = new 数据类型[数组的长度];</p><p>举例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.定义一个数组，存3个人的年龄，年龄未知</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> agesArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> scoresArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数组的默认初始化值</strong>：</p><p>整数类型：0</p><p>小数类型：0.0</p><p>布尔类型：false</p><p>字符类型：’\u0000’</p><p>引用类型：null</p><p><strong>数组两种初始化方式的区别</strong></p><p>静态初始化：int[] arr = {1,2,3,4,5};</p><p>动态初始化：int[] arr = new int[3];</p><p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p><p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p><p>使用场景：</p><p>只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。</p><p>已经明确了要操作的所有数据，推荐使用静态初始化。</p><p><strong>常见问题</strong></p><p>当访问了数组中不存在的索引，就会引发索引越界异常。</p><p>避免：</p><p> 针对于任意一个数组，索引的范围：<br>最小索引：0<br>最大索引：数组的长度 - 1<br>​ 数组名.length - 1</p><h3 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h3><p><strong>方法的概念</strong></p><p> 方法（method）是程序中最小的执行单元</p><ul><li>注意：<ul><li>方法必须先创建才可以使用，该过程成为方法定义</li><li>方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</li></ul></li></ul><h5 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h5><p><strong>无参数方法定义和调用</strong></p><ul><li><p>定义格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> 方法名 <span class="token punctuation">(</span>   <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 方法体;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>范例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> method <span class="token punctuation">(</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 方法体;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>调用格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>范例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：</p><p> 方法必须先定义，后调用，否则程序将报错</p></li></ul><p><strong>形参和实参</strong></p><ol><li>形参：方法定义中的参数</li></ol><p> 等同于变量定义格式，例如：int number</p><ol><li>实参：方法调用中的参数</li></ol><p> 等同于使用变量或常量，例如： 10 number</p><h5 id="带返回值方法定义和调用"><a href="#带返回值方法定义和调用" class="headerlink" title="带返回值方法定义和调用"></a>带返回值方法定义和调用</h5><ul><li><p>定义格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> 数据类型 方法名 <span class="token punctuation">(</span> 参数 <span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> 数据 <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>范例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEvenNumber</span><span class="token punctuation">(</span> <span class="token keyword">int</span> number <span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span>  <span class="token number">100</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意：<ul><li>方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错</li></ul></li></ul></li><li><p>调用格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">方法名 <span class="token punctuation">(</span> 参数 <span class="token punctuation">)</span> <span class="token punctuation">;</span>数据类型 变量名 <span class="token operator">=</span> 方法名 <span class="token punctuation">(</span> 参数 <span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>范例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">isEvenNumber <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">boolean</span>  flag <span class="token operator">=</span>  isEvenNumber <span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>注意：<ul><li>方法的返回值通常会使用变量接收，否则该返回值将无意义</li></ul></li></ul></li></ul><h5 id="方法的注意事项"><a href="#方法的注意事项" class="headerlink" title="方法的注意事项"></a>方法的注意事项</h5><ul><li>方法不能嵌套定义</li></ul><h5 id="方法的通用格式"><a href="#方法的通用格式" class="headerlink" title="方法的通用格式"></a>方法的通用格式</h5><ul><li><p>格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> 返回值类型 方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>   方法体<span class="token punctuation">;</span>    <span class="token keyword">return</span> 数据 <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解释：</p><ul><li><p>public static 修饰符，目前先记住这个格式</p><p>返回值类型 方法操作完毕之后返回的数据的数据类型</p><p> 如果方法操作完毕，没有数据返回，这里写void，而且方法体中一般不写return</p><p>方法名 调用方法时候使用的标识</p><p>参数 由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>方法体 完成功能的代码块</p><p>return 如果方法操作完毕，有数据返回，用于把数据返回给调用者</p></li></ul></li><li><p>定义方法时，要做到两个明确</p><ul><li>明确返回值类型：主要是明确方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</li><li>明确参数：主要是明确参数的类型和数量</li></ul></li><li><p>调用方法时的注意：</p><ul><li>void类型的方法，直接调用即可</li><li>非void类型的方法，推荐用变量接收调用</li></ul></li></ul><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><ul><li><p>方法重载概念</p><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ul><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ul></li><li><p>注意：</p><ul><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ul></li></ul><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><h5 id="类和对象的理解"><a href="#类和对象的理解" class="headerlink" title="类和对象的理解"></a>类和对象的理解</h5><p>客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。</p><ul><li>类<ul><li>类的理解<ul><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ul></li><li>类的组成<ul><li>属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）</li><li>行为：指事物能执行的操作，例如：手机事物（打电话，发短信）</li></ul></li></ul></li><li>类和对象的关系<ul><li>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>对象：是能够看得到摸的着的真实存在的实体</li><li>简单理解：<strong>类是对事物的一种描述，对象则为具体存在的事物</strong></li></ul></li></ul><h5 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h5><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><p>①定义类</p><p>②编写类的成员变量</p><p>③编写类的成员方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 类名 <span class="token punctuation">{</span><span class="token comment">// 成员变量</span>变量<span class="token number">1</span>的数据类型 变量<span class="token number">1</span>；变量<span class="token number">2</span>的数据类型 变量<span class="token number">2</span><span class="token punctuation">;</span>…<span class="token comment">// 成员方法</span>方法<span class="token number">1</span><span class="token punctuation">;</span>方法<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h5><ul><li>创建对象的格式：<ul><li>类名 对象名 = new 类名();</li></ul></li><li>调用成员的格式：<ul><li>对象名.成员变量</li><li>对象名.成员方法();</li></ul></li></ul><h4 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h4><h5 id="单个对象内存图"><a href="#单个对象内存图" class="headerlink" title="单个对象内存图"></a>单个对象内存图</h5><ul><li>成员变量使用过程</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/hzxZCUoHtQ4kcWv.png" alt="img"></p><ul><li>成员方法调用过程</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/OrbVSxHnI2vfkzQ.png" alt="img"></p><h5 id="多个对象内存图"><a href="#多个对象内存图" class="headerlink" title="多个对象内存图"></a>多个对象内存图</h5><ul><li>成员变量使用过程</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/6jhDHlCdxufWy8Q.png" alt="img"></p><ul><li>成员方法调用过程</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/ByJh7dbTsY6NiEu.png" alt="img"></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><h5 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h5><ul><li>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</li><li>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</li><li>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</li><li>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h5 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h5><ol><li><p>封装概述<br>是面向对象三大特征之一（封装，继承，多态）</p><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong></p></li><li><p>封装代码实现<br>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问<br>成员变量private，提供对应的getXxx()/setXxx()方法</p></li></ol><h5 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h5><p>private是一个修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li>被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作<ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li></ul><h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><ul><li>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）<ul><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li></ul></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="构造方法概述"><a href="#构造方法概述" class="headerlink" title="构造方法概述"></a>构造方法概述</h5><p>构造方法是一种特殊的方法</p><ul><li><p>作用：创建对象 Student stu = <strong>new Student();</strong></p></li><li><p>格式：</p><p>public class 类名{</p><p> 修饰符 类名( 参数 ) {</p><p> }</p><p>}</p></li></ul><h5 id="构造方法的注意事项"><a href="#构造方法的注意事项" class="headerlink" title="构造方法的注意事项"></a>构造方法的注意事项</h5><ul><li>构造方法的创建</li></ul><p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p><ul><li>构造方法的重载</li></ul><p>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p><ul><li>推荐的使用方式</li></ul><p>无论是否使用，都手工书写无参数构造方法</p><ul><li>重要功能！</li></ul><p>可以使用带参构造，为成员变量进行初始化</p><h5 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h5><p>① 类名需要见名知意</p><p>② 成员变量使用private修饰</p><p>③ 提供至少两个构造方法</p><ul><li>无参构造方法</li><li>带全部参数的构造方法</li></ul><p>④ get和set方法</p><p> 提供每一个成员变量对应的setXxx()/getXxx()</p><p>⑤ 如果还有其他行为，也需要写上</p><h4 id="键盘录入涉及到的方法如下："><a href="#键盘录入涉及到的方法如下：" class="headerlink" title="键盘录入涉及到的方法如下："></a>键盘录入涉及到的方法如下：</h4><h5 id="1）next（）、nextLine（）："><a href="#1）next（）、nextLine（）：" class="headerlink" title="1）next（）、nextLine（）："></a>1）next（）、nextLine（）：</h5><p>可以接受任意数据，但是都会返回一个字符串。</p><p>比如：键盘录入abc，那么会把abc看做字符串返回。</p><p> 键盘录入123，那么会把123看做字符串返回。</p><h5 id="2）nextInt（）："><a href="#2）nextInt（）：" class="headerlink" title="2）nextInt（）："></a>2）nextInt（）：</h5><p> 只能接受整数。</p><p>比如：键盘录入123，那么会把123当做int类型的整数返回。</p><p> 键盘录入小数或者其他字母，就会报错。</p><h5 id="3）nextDouble（）："><a href="#3）nextDouble（）：" class="headerlink" title="3）nextDouble（）："></a>3）nextDouble（）：</h5><p> 能接收整数和小数，但是都会看做小数返回。</p><p> 录入字母会报错。</p><h5 id="方法底层细节-："><a href="#方法底层细节-：" class="headerlink" title="方法底层细节 ："></a>方法底层细节 ：</h5><p><strong>第一个细节</strong>：</p><p>next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。</p><p><strong>第二个细节</strong>：</p><p>next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据。但是这些符号 + 后面的数据还在内存中并没有接收。如果后面还有其他键盘录入的方法，会自动将这些数据接收。</p><p><strong>第三个细节</strong>：</p><p>nextLine（）方法是把一整行全部接收完毕。</p><h5 id="结论（如何使用）"><a href="#结论（如何使用）" class="headerlink" title="结论（如何使用）"></a>结论（如何使用）</h5><p>键盘录入分为两套：</p><ul><li>next（）、nextInt（）、nextDouble（）这三个配套使用。</li></ul><p>如果用了这三个其中一个，就不要用nextLine（）。</p><ul><li>nextLine（）单独使用。</li></ul><p>如果想要整数，那么先接收，再使用Integer.parseInt进行类型转换。</p><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//键盘录入123</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时为字符串"</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时123是字符串</span><span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//键盘录入123</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时为整数："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//键盘录入123</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时为字符串"</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时123是字符串</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//想要整数再进行转换</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"此时为整数："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h5><ul><li><p>什么是API</p><p> API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p> 指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h5 id="如何使用API帮助文档"><a href="#如何使用API帮助文档" class="headerlink" title="如何使用API帮助文档"></a>如何使用API帮助文档</h5><ul><li>打开帮助文档</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/1R3VwQNOfx2lePA.png" alt="img"></p><ul><li>找到索引选项卡中的输入框</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/4FG9bN3jzItv6qD.png" alt="img"></p><ul><li>在输入框中输入Random</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/4FG9bN3jzItv6qD.png" alt="img"></p><ul><li>看类在哪个包下</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/9cW28ZxkPUm7heE.png" alt="img"></p><ul><li>看类的描述</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/l6uV3PQq7WNhEBg.png" alt="img"></p><ul><li>看构造方法</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/l6uV3PQq7WNhEBg.png" alt="img"></p><ul><li>看成员方法</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/03/21/3oCI8pby2ZD9On6.png" alt="img"></p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="String类概述"><a href="#String类概述" class="headerlink" title="String类概述"></a>String类概述</h5><p> String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h5 id="String类的特点"><a href="#String类的特点" class="headerlink" title="String类的特点"></a>String类的特点</h5><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h5 id="String类的构造方法"><a href="#String类的构造方法" class="headerlink" title="String类的构造方法"></a>String类的构造方法</h5><ul><li><p>常用的构造方法</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public String()</td><td align="left">创建一个空白字符串对象，不含有任何内容</td></tr><tr><td align="left">public String(char[] chs)</td><td align="left">根据字符数组的内容，来创建字符串对象</td></tr><tr><td align="left">public String(byte[] bys)</td><td align="left">根据字节数组的内容，来创建字符串对象</td></tr><tr><td align="left">String s = “abc”;</td><td align="left">直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li></ul><h5 id="创建字符串对象两种方式的区别"><a href="#创建字符串对象两种方式的区别" class="headerlink" title="创建字符串对象两种方式的区别"></a>创建字符串对象两种方式的区别</h5><ul><li><p>通过构造方法创建</p><p> 通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p> 以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ul><h5 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h5><p><strong>==号的作用</strong></p><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h5 id="equals方法的作用"><a href="#equals方法的作用" class="headerlink" title="equals方法的作用"></a>equals方法的作用</h5><ul><li><p>方法介绍</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span>     比较两个字符串内容是否相同、区分大小写<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p><p>当我们在拼接字符串和反转字符串的时候会使用到</p><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderDemo3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建对象</span>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.添加元素</span>        <span class="token comment">/*sb.append(1);        sb.append(2.3);        sb.append(true);*/</span>        <span class="token comment">//反转</span>        sb<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印</span>        <span class="token comment">//普及：</span>        <span class="token comment">//因为StringBuilder是Java已经写好的类</span>        <span class="token comment">//java在底层对他做了一些特殊处理。</span>        <span class="token comment">//打印对象不是地址值而是属性值。</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringBuilderDemo4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建对象</span>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.添加字符串</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"ddd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//aaabbbcccddd</span>        <span class="token comment">//3.再把StringBuilder变回字符串</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//aaabbbcccddd</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h4><ul><li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li><li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</li><li>JDK8出现的</li></ul><p>基本使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.创建一个对象，并指定中间的间隔符号</span><span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">"---"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.添加元素</span>sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.打印结果</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//aaa---bbb---ccc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//1.创建对象</span><span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">,</span><span class="token string">"["</span><span class="token punctuation">,</span><span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2.添加元素</span>sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> len <span class="token operator">=</span> sj<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//15</span><span class="token comment">//3.打印</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[aaa, bbb, ccc]</span><span class="token class-name">String</span> str <span class="token operator">=</span> sj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[aaa, bbb, ccc]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="关于字符串的小扩展："><a href="#关于字符串的小扩展：" class="headerlink" title="关于字符串的小扩展："></a>关于字符串的小扩展：</h4><ol><li><p>字符串存储的内存原理</p><p>String s = “abc”；直接赋值</p><p>特点：</p><p> 此时字符串abc是存在字符串常量池中的。</p><p> 先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</p><p>所以，直接赋值的方式，代码简单，而且节约内存。</p></li><li><p>new出来的字符串</p><p>看到new关键字，一定是在堆里面开辟了一个小空间。</p><p>String s1 = new String（“abc”）；</p><p>String s2 = “abc”；</p><p>s1记录的是new出来的，在堆里面的地址值。</p><p>s2是直接赋值的，所以记录的是字符串常量池中的地址值。</p></li><li><p>==号比较的到底是什么？</p><p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p><p>如果比较的是引用数据类型：比的是地址值是否相等。</p><p>结论：==只能用于比较基本数据类型。不能比较引用数据类型。</p></li></ol><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="集合和数组的优势对比："><a href="#集合和数组的优势对比：" class="headerlink" title="集合和数组的优势对比："></a>集合和数组的优势对比：</h5><ol><li>长度可变</li><li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li></ol><h5 id="ArrayList类概述"><a href="#ArrayList类概述" class="headerlink" title="ArrayList类概述"></a>ArrayList类概述</h5><ul><li><p>什么是集合</p><p> 提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p> 长度可以变化，只能存储引用数据类型。</p></li><li><p>泛型的使用</p><p> 用于约束集合中存储元素的数据类型</p></li></ul><h5 id="ArrayList类常用方法"><a href="#ArrayList类常用方法" class="headerlink" title="ArrayList类常用方法"></a>ArrayList类常用方法</h5><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public ArrayList()</td><td align="left">创建一个空的集合对象</td></tr></tbody></table><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a><strong>成员方法</strong></h4><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public boolean add(要添加的元素)</td><td align="left">将指定的元素追加到此集合的末尾</td></tr><tr><td align="left">public boolean remove(要删除的元素)</td><td align="left">删除指定元素,返回值表示是否删除成功</td></tr><tr><td align="left">public E remove(int index)</td><td align="left">删除指定索引处的元素，返回被删除的元素</td></tr><tr><td align="left">public E set(int index,E element)</td><td align="left">修改指定索引处的元素，返回被修改的元素</td></tr><tr><td align="left">public E get(int index)</td><td align="left">返回指定索引处的元素</td></tr><tr><td align="left">public int size()</td><td align="left">返回集合中的元素的个数</td></tr></tbody></table><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListDemo02</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建集合</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//添加元素</span>        array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//public boolean remove(Object o)：删除指定的元素，返回删除是否成功</span>        <span class="token comment">//        System.out.println(array.remove("world"));</span>        <span class="token comment">//        System.out.println(array.remove("javaee"));</span>        <span class="token comment">//public E remove(int index)：删除指定索引处的元素，返回被删除的元素</span>        <span class="token comment">//        System.out.println(array.remove(1));</span>        <span class="token comment">//IndexOutOfBoundsException</span>        <span class="token comment">//        System.out.println(array.remove(3));</span>        <span class="token comment">//public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</span>        <span class="token comment">//        System.out.println(array.set(1,"javaee"));</span>        <span class="token comment">//IndexOutOfBoundsException</span>        <span class="token comment">//        System.out.println(array.set(3,"javaee"));</span>        <span class="token comment">//public E get(int index)：返回指定索引处的元素</span>        <span class="token comment">//        System.out.println(array.get(0));</span>        <span class="token comment">//        System.out.println(array.get(1));</span>        <span class="token comment">//        System.out.println(array.get(2));</span>        <span class="token comment">//System.out.println(array.get(3)); //？？？？？？ 自己测试</span>        <span class="token comment">//public int size()：返回集合中的元素的个数</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//输出集合</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"array:"</span> <span class="token operator">+</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/d04bd5bc.html"/>
      <url>/posts/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章：操作系统引论"><a href="#第一章：操作系统引论" class="headerlink" title="第一章：操作系统引论"></a>第一章：操作系统引论</h3><h4 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h4><h5 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h5><ul><li><strong>并发</strong>：是指两个或多个活动在同一给定的时间间隔中进行。</li><li><strong>共享</strong>：是指计算机系统中的资源被多个进程所共用。</li><li><strong>异步</strong>：进程以不可预知的速度向前推进。</li><li><strong>虚拟</strong>：把一个物理上的实体变为若干个逻辑上的对应物。</li></ul><p><strong>最基本特征</strong>：<strong>并发</strong>、<strong>共享</strong>（两者互为存在条件）</p><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>处理机管理：主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li><li>存储器管理：主要包括内存分配、地址映射、内存保护与共享和内存扩充等功能。</li><li>文件管理：包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li><li>设备管理：主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li></ul><h5 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h5><ul><li><p>人工操作阶段（此阶段无操作系统）</p><ul><li>缺点：人机速度矛盾</li></ul></li><li><p>批处理阶段（操作系统开始出现）</p><ul><li><p>单道批处理阶段</p></li><li><p>多道批处理阶段（操作系统正式诞生）</p><p>目的：提高系统资源的利用率</p><ul><li>优：多道程序并发执行，资源利用率高</li><li>缺：不提供人机交互能力（缺少交互性）</li></ul></li></ul></li><li><p>分时操作系统(不可以插队，有了人机交互)</p><ul><li>优：提供人机交互</li><li>缺：不能优先处理紧急事务</li></ul></li><li><p>实时操作系统（可以插队）</p><ul><li>硬实时系统：必须在被控制对象规定时间内完成（火箭发射）</li><li>软实时系统：可以松一些（订票）</li></ul><p>优：能优先处理紧急任务</p></li></ul><p>从可靠性看实时操作系统更强，从交互性看分时操作系统更强</p><h4 id="不得不知的概念"><a href="#不得不知的概念" class="headerlink" title="不得不知的概念"></a>不得不知的概念</h4><h5 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h5><ul><li>特权指令：不允许用户程序使用（只允许操作系统使用）。如IO指令、置中断指令</li><li>非特权指令：普通的运算指令</li></ul><h5 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h5><ul><li>内核程序：系统的管理者，可执行一切指令、运行在核心态</li><li>应用程序：普通用户程序只能执行非特权指令，运行在用户态</li></ul><h5 id="处理机状态"><a href="#处理机状态" class="headerlink" title="处理机状态"></a>处理机状态</h5><ul><li>用户态（目态）：CPU只能执行非特权指令</li><li>核心态(又称管态、内核态)：可以执行所有指令</li><li>用户态到核心态：通过中断（是硬件完成的）</li><li>核心态到用户态：特权指令Psw的标志位0用户态1核心态</li></ul><p>常考谁在用户态执行，谁在核心态执行</p><h5 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h5><ol><li>处于操作系统的最低层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成。</li><li>这些程序的运行时间都较短，而目调用频繁。</li></ol><h5 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h5><ul><li>内中断(异常，信号来自内部)<ul><li>自愿中断——指令中断</li><li>强迫中断<ul><li>硬件中断</li><li>软件中断</li></ul></li></ul></li><li>外中断(中断，信号来着外部)<ul><li>外设请求</li><li>人工干预</li></ul></li></ul><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>系统给程序员（应用程序）提供的唯一接口，可获得OS的服务。在用户态发生，核心态处理</p><h5 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h5><ul><li>大内核</li><li>微内核</li></ul><h3 id="第二章：进程调度"><a href="#第二章：进程调度" class="headerlink" title="第二章：进程调度"></a>第二章：进程调度</h3><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><h5 id="引入进程目的"><a href="#引入进程目的" class="headerlink" title="引入进程目的"></a>引入进程目的</h5><p>为了更好地描述和控制程序并发执行，实现操作系统的并发性和共享性(<strong>进程是动态的，程序是静态的</strong>)</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>是计算机中的程序关于某数据集合上的一次运行活动，<strong>是系统进行资源分配和调度的基本单位</strong></p><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>PCB<ul><li>保存进程运行期间相关的数据，是进程存在的<strong>唯一标志</strong></li></ul></li><li>程序段<ul><li>能被进程调度到CPU的代码</li></ul></li><li>数据段</li></ul><h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><ul><li>状态总类<ul><li>运行态<ul><li>进程正在占用CPU</li></ul></li><li>就绪态<ul><li>进程已处于准备运行的状态，即进程获得了处理机外的一切所需资源，一旦得到处理机即可运行。</li></ul></li><li>阻塞态</li><li>创建状态<ul><li>进程正在被创建</li></ul></li><li>结束状态<ul><li>进程正在从系统消失</li></ul></li></ul></li><li>状态变化<ul><li>就绪态–&gt;运行态</li><li>运行态–&gt;就绪态</li><li>运行态–&gt;阻塞态</li><li>阻塞态–&gt;就绪态</li></ul></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2023/02/18/1TteVN5Dwl7O638.png" alt="image-20230218024257503"></p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><ul><li>引入目的：为了更好的使用多道程序并发执行，提高资源利用率和系统吞吐量</li><li>特点：是程<strong>序执行的最小单位</strong>，基本不拥有任何操作资源（<strong>调度的基本单位</strong>）</li></ul><h4 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>高级调度（作业调度）（次数少）</li><li>中级调度（内存对换）（次数中等）</li><li>低级调度（进程调度）（次数多）</li></ul><h5 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h5><ul><li>剥夺式</li><li>非剥夺式</li></ul><h5 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h5><ul><li>CPU利用率</li><li>系统吞吐量</li><li>周转时间</li><li>等待时间</li><li>响应时间</li></ul><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul><li>先来先服务</li><li>短作业优先</li><li>优先级调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转</li><li>多级反馈队列调度算法</li></ul><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><h5 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h5><p>协调进程之间的相互制约关系</p><h5 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h5><ul><li>同步<ul><li>亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</li></ul></li><li>互斥<ul><li>也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另进程才允许去访问此临界资源。</li></ul></li></ul><h5 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h5><p>一次仅允许一个进程使用的资源（打印机，共享缓冲区，共享变量，公用列队）</p><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>在每个进程中访问临界资源的<strong>那段程序</strong></p><h5 id="临界区互斥"><a href="#临界区互斥" class="headerlink" title="临界区互斥"></a>临界区互斥</h5><p><strong>原则</strong>o</p><ul><li>空闲让进：如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</li><li>忙则等待：任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区则其它所有试图进入临界区的进程必须等待。</li><li>有限等待：进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</li><li>让权等待：如果进程不能进入自己的临界区则应让出CPU,避免进程出现“忙等”现象。</li></ul><h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><p>信号量 利用PV操作实现互斥</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h5><p>非剥夺资源的竞争和进程的不恰当推进顺序（与饥饿的区别）</p><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>多个进程因竞争资源而造成的一种僵局，如果没有外力，这些进程将无法推进</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>预防死锁<ul><li>破坏互斥条件</li><li>破坏不剥夺条件</li><li>破坏请求和保持条件</li><li>破坏循环等待条件</li></ul></li><li>避免死锁<ul><li>安全状态</li><li>银行家算法</li></ul></li><li>检测死锁：利用死锁定理</li><li>解除死锁<ul><li>资源剥夺法</li><li>撤销进程法</li><li>进程回退法</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw知识汇总</title>
      <link href="/posts/de05bc9b.html"/>
      <url>/posts/de05bc9b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安全常识基础"><a href="#一、安全常识基础" class="headerlink" title="一、安全常识基础"></a>一、安全常识基础</h1><h2 id="1-1-安全简介"><a href="#1-1-安全简介" class="headerlink" title="1.1 安全简介"></a>1.1 安全简介</h2><h3 id="1-1-1-了解当前安全状况"><a href="#1-1-1-了解当前安全状况" class="headerlink" title="1.1.1 了解当前安全状况"></a>1.1.1 了解当前安全状况</h3><h2 id="1-2-热门安全事件"><a href="#1-2-热门安全事件" class="headerlink" title="1.2 热门安全事件"></a>1.2 热门安全事件</h2><h3 id="1-2-1-了解热门安全事件"><a href="#1-2-1-了解热门安全事件" class="headerlink" title="1.2.1 了解热门安全事件"></a>1.2.1 了解热门安全事件</h3><h2 id="1-3-安全术语"><a href="#1-3-安全术语" class="headerlink" title="1.3 安全术语"></a>1.3 安全术语</h2><ul><li><strong>0DAY</strong></li></ul><p>“零日漏洞”(zero-day)又叫零时差攻击，是指被发现后立即被恶意利用的安全漏洞。</p><ul><li><strong>RCE</strong></li></ul><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><ul><li><strong>EXP</strong></li></ul><p>exploit，漏洞利用；利用漏洞攻击系统的代码。</p><ul><li><strong>POC</strong></li></ul><p>漏洞证明，漏洞报告中，通过一段描述或一个样例来证明漏洞确实存在。</p><ul><li><strong>CVE</strong></li></ul><p>公共漏洞和暴露，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</p><ul><li><strong>Payload</strong></li></ul><p>（有效攻击负载）是包含在你用于一次漏洞利用（exploit）中的攻击代码。</p><ul><li><strong>后门</strong></li></ul><p>绕过安全控制而获取对程序或系统访问权的方法。</p><ul><li><strong>webshell</strong></li></ul><p>Webshell是通过服务器开放的端口获取服务器的某些权限。</p><h3 id="1-3-6-常见高危风险端口"><a href="#1-3-6-常见高危风险端口" class="headerlink" title="1.3.6 常见高危风险端口"></a>1.3.6 常见高危风险端口</h3><table><thead><tr><th align="left">端口</th><th align="left">服务</th><th align="left">渗透测试</th></tr></thead><tbody><tr><td align="left">tcp 20,21</td><td align="left">FTP（文件传输协议）</td><td align="left">允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</td></tr><tr><td align="left">tcp 22</td><td align="left">SSH （安全外壳协议 ）</td><td align="left">可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等</td></tr><tr><td align="left">tcp 23</td><td align="left">Telnet （ 远程终端协议）</td><td align="left">爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令</td></tr><tr><td align="left">tcp 25</td><td align="left">SMTP（简单邮件传输协议）</td><td align="left">邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td></tr><tr><td align="left">tcp/udp 53</td><td align="left">DNS（域名系统）</td><td align="left">允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td></tr><tr><td align="left">tcp 80</td><td align="left">Web服务端口</td><td align="left">可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等……</td></tr><tr><td align="left">tcp 1433</td><td align="left">SQL Server（数据库管理系统）</td><td align="left">注入,提权,sa弱口令,爆破</td></tr><tr><td align="left">tcp 3306</td><td align="left">MySQL（数据库）</td><td align="left">注入,提权,爆破</td></tr><tr><td align="left">tcp 3389</td><td align="left">Windows rdp（桌面协议）</td><td align="left">shift后门[需要03以下的系统],爆破,ms12-020</td></tr></tbody></table><h1 id="二、操作系统基础"><a href="#二、操作系统基础" class="headerlink" title="二、操作系统基础"></a>二、操作系统基础</h1><h2 id="2-1-windows"><a href="#2-1-windows" class="headerlink" title="2.1 windows"></a>2.1 windows</h2><h3 id="2-1-1-常用命令"><a href="#2-1-1-常用命令" class="headerlink" title="2.1.1 常用命令"></a>2.1.1 常用命令</h3><ol><li><h4 id="用户-x2F-组管理"><a href="#用户-x2F-组管理" class="headerlink" title="用户/组管理"></a>用户/组管理</h4></li></ol><ul><li><strong>添加或删除用户</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#添加一个永不过期的用户，并设置登录口令</span>net user <span class="token punctuation">[</span>userName<span class="token punctuation">]</span><span class="token punctuation">[</span>password<span class="token punctuation">]</span> /add /expires:never<span class="token comment">#删除用户</span>net user <span class="token punctuation">[</span>userName<span class="token punctuation">]</span> /delete<span class="token comment">#将用户添加到管理员组</span>net localgroup Administrators <span class="token punctuation">[</span>userName<span class="token punctuation">]</span> /add<span class="token comment">#将用户从管理组删除</span>net localgroup Administrators <span class="token punctuation">[</span>userName<span class="token punctuation">]</span> /delete<span class="token comment">#修改当前用户密码</span>net user <span class="token punctuation">[</span>userName<span class="token punctuation">]</span><span class="token punctuation">[</span>password<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>激活或禁用用户</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#激活用户</span>net user <span class="token punctuation">[</span>userName<span class="token punctuation">]</span> /active:yes<span class="token comment">#禁用用户</span>net user <span class="token punctuation">[</span>userName<span class="token punctuation">]</span> /active:no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>查看用户</strong></li></ul><p>​<code>net user</code></p><ul><li><strong>新建或删除用户组</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#新建用户组</span>net localgroup <span class="token punctuation">[</span>groupName<span class="token punctuation">]</span> /add<span class="token comment">#删除用户组</span>net localgroup <span class="token punctuation">[</span>groupName<span class="token punctuation">]</span> /delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4></li></ol><ul><li><strong>列出目录结构</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dir</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>:<span class="token punctuation">\</span><span class="token punctuation">[</span>folderName<span class="token punctuation">]</span><span class="token function">dir</span> /a:h /s<span class="token comment">#显示当前目录及其子目录下的隐藏文件</span><span class="token function">dir</span> /a:s /s<span class="token comment">#显示当前目录及其子目录下的系统文件</span><span class="token function">dir</span> /a:r /s<span class="token comment">#显示当前目录及其子目录下的只读文件</span><span class="token function">dir</span> /a:a /s<span class="token comment">#显示当前目录及其子目录下的存档文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>创建文件并向文件输出信息</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"test text"</span> <span class="token operator">&gt;</span> <span class="token number">1</span>.txt<span class="token comment">#覆盖</span><span class="token builtin class-name">echo</span> <span class="token string">"test rext"</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>.txt<span class="token comment">#追加</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>创建目录</strong></li></ul><p>​<code>md [folderName]</code></p><ul><li><strong>切换目录、盘符</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>:<span class="token punctuation">\</span><span class="token punctuation">[</span>folderName<span class="token punctuation">]</span>d:<span class="token comment">#切换到 D 盘</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>删除文件或目录</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">del <span class="token punctuation">[</span>fileName<span class="token punctuation">]</span><span class="token comment">#删除文件</span>rd <span class="token punctuation">[</span>folderName<span class="token punctuation">]</span><span class="token comment">#删除空目录（目录中不能有子目录和文件）</span>rd <span class="token punctuation">[</span>folderName<span class="token punctuation">]</span> /S /Q<span class="token comment">#删除目录并同时删除目录中的子目录以及文件 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>查看文件的内容</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">type</span> <span class="token punctuation">[</span>fileName<span class="token punctuation">]</span><span class="token comment">#在 DOS 下查看</span>start <span class="token punctuation">[</span>fileName<span class="token punctuation">]</span><span class="token comment">#调用默认程序查看</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>设置文件或目录属性</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">attrib +S +H <span class="token punctuation">[</span>path<span class="token punctuation">]</span>:<span class="token punctuation">\</span><span class="token punctuation">[</span>fileName<span class="token punctuation">]</span><span class="token comment">#添加系统文件和隐藏文件属性</span><span class="token comment">#处理文件夹及子文件里匹配的文件（包含该文件夹）</span>attrib +S +H <span class="token punctuation">[</span>path<span class="token punctuation">]</span>:<span class="token punctuation">\</span><span class="token punctuation">[</span>fileName<span class="token punctuation">]</span> /S /D/S 处理当前文件夹及其子文件夹中的匹配文件 /D 也处理文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>重命名</strong></li></ul><p>​<code>ren [fileName1][fileName2]</code></p><ul><li><strong>显示目录树</strong></li></ul><p>​<code>tree [path]:\[folderName] /F</code></p><ul><li><strong>查找文件内容</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token punctuation">[</span>/V<span class="token punctuation">]</span><span class="token punctuation">[</span>/C<span class="token punctuation">]</span><span class="token punctuation">[</span>/N<span class="token punctuation">]</span><span class="token punctuation">[</span>/I<span class="token punctuation">]</span><span class="token punctuation">[</span>/OFF<span class="token punctuation">[</span>LINE<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token string">"string"</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>drive:<span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token punctuation">]</span>/V 显示所有未包含指定字符串的行。/C 仅显示包含字符串的行数。/N 显示行号。 /I 搜索字符串时忽略大小写。/OFF<span class="token punctuation">[</span>LINE<span class="token punctuation">]</span> 不要跳过具有脱机属性集的文件。<span class="token string">"string"</span> 指定要搜索的文本字符串。<span class="token punctuation">[</span>drive:<span class="token punctuation">]</span><span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">[</span>filename<span class="token punctuation">]</span> 指定要搜索的文件<span class="token function">find</span> <span class="token string">"abc"</span> <span class="token number">1</span>.txt <span class="token comment">#查找含有abc的行,并输出该行。</span><span class="token function">find</span> /n <span class="token string">"abc"</span> <span class="token number">1</span>.txt <span class="token comment">#查找含有abc的行,并输出该行和行号。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><h4 id="网络-x2F-服务"><a href="#网络-x2F-服务" class="headerlink" title="网络/服务"></a>网络/服务</h4></li></ol><ul><li><strong>ping</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> -t -l <span class="token number">65500</span> <span class="token punctuation">[</span>IP or domain<span class="token punctuation">]</span><span class="token comment">#死亡之ping</span><span class="token comment">#65500 表示数据长度上限，-t 表示不停地ping目标地址</span><span class="token function">ping</span> <span class="token punctuation">[</span>ip<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>ipconfig</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig -all<span class="token comment">#查看当前所有的ip 地址信息</span>ipconfig /release<span class="token comment">#清除当前获取到的ip 地址 </span>ipconfig /renew<span class="token comment">#重新获取ip 地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>natstat</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -ano<span class="token comment">#列出所有端口的使用情况 </span><span class="token function">netstat</span> -no<span class="token comment">#显示连接进程的情况，通常用于查找是否有木马程序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>arp （地址解析协议）</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">arp -a<span class="token comment">#显示 ARP 列表</span>arp -d<span class="token comment">#清除 ARP 列表，需要管理员权限</span>arp -s <span class="token punctuation">[</span>ip<span class="token punctuation">]</span><span class="token punctuation">[</span>macAddress<span class="token punctuation">]</span><span class="token comment">#添加静态项</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>tracert</strong></li></ul><p>​<code>tracert [ip or domain]#跟踪路由</code></p><ul><li><strong>nslookup</strong></li></ul><p>​<code>nslookup www.baidu.com#查询指定域名的dns信息</code></p><ul><li><strong>route</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">route print<span class="token comment">#打印路由表</span>route <span class="token function">add</span> <span class="token punctuation">[</span>network<span class="token punctuation">]</span> mask <span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token punctuation">[</span>next-hop<span class="token punctuation">]</span><span class="token comment">#新增路由</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>net</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">net view<span class="token comment">#查看当前局域网内的其他连接者</span>net start<span class="token comment">#查看开启了哪些服务</span>net start <span class="token punctuation">[</span>serviceName<span class="token punctuation">]</span><span class="token comment">#开启某一个服务</span>net stop <span class="token punctuation">[</span>serviceName<span class="token punctuation">]</span><span class="token comment">#停止某一个服务</span><span class="token comment">#将共享的某一个服务器的C盘映射成K盘，攻击者常用命令</span>net use k:<span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token punctuation">[</span>ipAddress<span class="token punctuation">]</span><span class="token punctuation">\</span>c$<span class="token comment">#以下命令建议需管理员权限</span>net share<span class="token comment">#查看本地开启的共享</span>net share ipc$<span class="token comment">#开启ipc$共享</span>net share ipc$ /del <span class="token comment">#删除ipc$共享</span>net share c$ /del <span class="token comment">#删除C盘的共享</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-2-Windows服务"><a href="#2-1-2-Windows服务" class="headerlink" title="2.1.2 Windows服务"></a>2.1.2 Windows服务</h3><ul><li><strong>常见进程</strong></li></ul><p>System.exe ：系统进程，一个重要的进程。</p><p>System Idle Process.exe ：系统进程，它的作用是显示系统有多少闲置的cpu资源。</p><p>svchost Service Host Process：是一个标准的动态连接库主机处理服务。Svchost用来启动服务。Svchost只是负责为这些服务提供启动的条件，其自身并不能实现任何服务的功能，也不能为用户提供任何服务。 经常会被病毒利用进行dll注入的进程。</p><p>explorer.exe ：用于控制Windows图形，包括开始菜单、任务栏，桌面和文件管理。</p><p>lsass.exe ：系统进程，这是一个本地安全权限服务管理 进程详解：管理 IP安全策略以及启动 ISAKMP/Oakley (IKE) 和 IP 安全驱动程序。</p><p>services.exe：系统进程用于管理启动和停止Windows服务，该进程也管理计算机启动和关机时的运 行的服务，所以很重要。</p><p>alg.exe：这是一个应用层网关服务用于网络共享，alg.exe是微软Windows操作系统自带的程序。它 用于处理微软Windows网络连接共享和网络连接防火墙。</p><p>csrss.exe： 微软客户端/服务端运行时子系统。该进程管理Windows图形相关任务。注意：有些病 毒也会创业该进程。</p><p>mdm.exe ：微软Windows进程除错程序。用于使用可视化脚本工具对Internet Explorer除错。</p><p>taskmgr.exe： 任务管理器进程。</p><p>rundll32.exe：用于在内存中运行DLL文件，它们会在应用程序中被使用，一般有多个。</p><p>smss.exe： 微软Windows操作系统的一部分。</p><p>winlogon ：管理用户登录和退出的。</p><p>Wuauclt.exe：Windows自动升级管理程序。</p><p>spoolsv.exe ：打印的进程</p><ul><li><strong>进程查看辅助工具</strong></li></ul><p>Pchunter </p><p>ProcessExplorer</p><p>ProcessHacker</p><p>ProcessMonitor<br>火绒剑</p><h3 id="2-1-3-Windows权限"><a href="#2-1-3-Windows权限" class="headerlink" title="2.1.3 Windows权限"></a>2.1.3 Windows权限</h3><ul><li><strong>某些文件位置</strong></li></ul><p>C:\Windows：Windows操作系统中最核心的文件夹，大部分系统文件都在此文件夹下。 </p><p>C:\Windows\Fonts：字体文件夹，有些病毒会存放在此文件夹下。</p><p>C:\Windows\System32：Windows文件夹中最重要的文件夹，一般用于存放Windows的系统文件和硬件驱动程序。</p><p>C:\Windows\Temp：系统临时文件夹，有些病毒会存放在此文件夹下。</p><p>C:\Windows\system32\dirvers ：Windows驱动文件夹，有些驱动病毒存放会在此文件夹下。</p><ul><li><p><strong>本地用户和组类型</strong></p><ul><li><p>用户账户</p><ul><li>本地用户</li><li>域用户</li></ul></li><li><p>组账户</p><ul><li>everyone组</li><li>network组</li></ul></li></ul></li><li><p><strong>安全标识符</strong></p></li></ul><p>安全主体的代表（标识用户、组和计算机账户的唯一编码）</p><p>范例：S-1-5-21-1736401710-1141508419-1540318053-1000</p><ul><li><strong>隐藏账户</strong></li></ul><p>账户被隐藏，无法通过net user命令查看。但可在用户列表中进行查看。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/ZgfBdbTLHarlQtR.png" alt="image-20220523165226762"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/TsF7uil4qCjhLDU.png" alt="image-20220523165244788"></p><ul><li><strong>文件权限</strong></li></ul><p>使用访问控制列表进行文件权限管理</p><p>权限： 完全控制、修改、 读取和执行、读取、写入、特别的权限</p><h2 id="2-2-linux"><a href="#2-2-linux" class="headerlink" title="2.2 linux"></a>2.2 linux</h2><h3 id="2-2-1-常用命令"><a href="#2-2-1-常用命令" class="headerlink" title="2.2.1 常用命令"></a>2.2.1 常用命令</h3><ul><li><strong>命令帮助</strong></li></ul><p> <strong>–help参数：</strong></p><p>如果想查看某个命令的帮助说明，可以在命令后输入—help参数。</p><p> <strong>man命令：</strong></p><p>查看命令的正式说明文档，比较长 </p><p> <strong>格式</strong>：man （命令）</p><ol><li><h4 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a><strong>文件目录管理</strong></h4></li></ol><ul><li><strong>目录操作</strong></li></ul><p> <strong>ls命令</strong>：</p><p>ls命令用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件。</p><p><strong>命令格式：</strong></p><p><code>ls (选项) (参数)</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> -a<span class="token comment">#显示当前目录下包括隐藏文件在内的所有文件列表</span><span class="token function">ls</span> -t<span class="token comment">#最近修改的文件显示在最上面</span><span class="token function">ls</span> –l<span class="token comment">#列出文件和文件夹的详细信息</span><span class="token function">ls</span> -al<span class="token comment">#显示当前目录下包括影藏文件在内的所有文件详细信息</span><span class="token function">ls</span> -lt<span class="token comment">#按时间列出文件和文件夹详细信息</span><span class="token function">ls</span> -ltr<span class="token comment">#按修改时间列出文件和文件夹详细信息</span><span class="token function">ls</span> -lut<span class="token comment">#按访问时间顺序查看</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>mkdir命令：</strong></p><p>mkdir mkdir命令目录基本操作 mkdir命令用来创建目录。该命令创建由dirname命名的目录。如果 在目录名的前面没有加任何路径名，则在当前目录下创建由dirname指定的目录；如果给出了一个 已经存在的路径，将会在该目录下创建一个指定的目录。在创建目录时，应保证新建的目录与它所<br>在目录下的文件没有重名。</p><p><strong>命令格式</strong>：</p><p><code>mkdir [选项] 目录名称</code></p><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在目录/tmp下建立子目录 /eshare/破军，并且只有文件主有读、写和执行权限，其他人无权访问</span><span class="token function">mkdir</span> -pm <span class="token number">700</span> /tmp/eshare/破军<span class="token comment">#-m 建立目录的同时设置目录的权限</span><span class="token comment">#-p 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>rm命令：</strong></p><p>rm命令可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其 子目录均删除掉。对于链接文件，只是删除整个链接文件，而原有文件保持不变。</p><p><strong>命令格式：</strong></p><p><code>rm [选项] 目录名称</code></p><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -f 文件名<span class="token comment">#强行删除文件系统不再提示</span><span class="token function">rm</span> -r 文件名<span class="token comment">#将当前目录及子目录中所有档案删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>文件权限属性设置</strong></li></ul><p><strong>chmd命令：</strong></p><p>chmod命令用来变更文件或目录的权限。</p><p>权限范围的表示法如下： </p><p>u User，即文件或目录的拥有者；</p><p>g Group，即文件或目录的所属群组；</p><p>o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围； </p><p>a All，即全部的用户，包含拥有者，所属群组以及其他用户；</p><p>r 读取权限，数字代号为”4”; </p><p>w 写入权限，数字代号为”2”；</p><p>x 执行或切换权限，数字代号为”1”；</p><p>-不具任何权限，数字代号为”0”；</p><p>s 特殊功能说明：变更文件或目录的权限。</p><p>linux 文件的用户权限的分析图</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/3KVlpm1g8UitvPe.png" alt="image-20220523172317446"></p><pre class="line-numbers language-bsh" data-language="bsh"><code class="language-bsh">#为文件hello.sh设置自己可以执行，组员可以写入的权限 chmod u+x,g+w hello.sh chmod u=rwx,g=rw,o=r hello.sh chmod 764 hello.sh#对文件hello.sh的u,g,o都设置可执行属性chmod a+x hello.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>文件查找</strong></li></ul><p><strong>find命令：</strong></p><p>find命令用来在指定目录下查找文件。</p><p><strong>语法：</strong></p><p><code>find (选项) (参数)</code></p><p>参数：查找文件的起始目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#根据文件或者正则表达式进行匹配：</span><span class="token function">find</span> / -name <span class="token string">"*.txt"</span><span class="token comment">#在/目录下查找以.txt结尾的文件名</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -name <span class="token string">"*.txt"</span> -o -name <span class="token string">"*.pdf"</span><span class="token comment">#当前目录及子目录下查找所有以.txt和.pdf结尾的文件</span><span class="token comment">#否定参数</span><span class="token function">find</span> /home <span class="token operator">!</span> -name <span class="token string">"*.txt"</span><span class="token comment">#找出/home下不是以.txt结尾的文件</span><span class="token comment">#根据文件时间戳进行搜索</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f 时间戳UNIX/Linux文件系统每个文件都有三种时间戳： 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。 -mtime –ctime都可以用来根据文件创建时间来查找，-ctime相对-mtime的区别就是权限修改了，-ctime可以查到，-mtime不行。<span class="token comment">#实例</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -atime -7<span class="token comment">#搜索最近七天内被访问过的所有文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -atime <span class="token number">7</span><span class="token comment">#搜索恰好在七天前被访问过的所有文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -atime +7<span class="token comment">#搜索超过七天被访问过的所有文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -amin +10<span class="token comment">#搜索访问时间超过10分钟的所有文件</span><span class="token comment">#根据文件权限/所有权进行匹配</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -perm <span class="token number">777</span><span class="token comment">#当前目录下搜索出权限为777的文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -name <span class="token string">"*.php"</span> <span class="token operator">!</span> -perm <span class="token number">644</span>  <span class="token comment">#找出当前目录下权限不是644的php文件</span><span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -user tom<span class="token comment">#找出当前目录用户tom拥有的所有文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>文件内容查看</strong></li></ul><p><strong>more命令：</strong></p><p>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一 页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键<br>就会往回（back）一页显示。</p><p><strong>语法：</strong></p><p><code>more (选项) (参数)</code></p><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#设more.txt是当前目录下的文件</span><span class="token function">more</span> more.txt<span class="token comment">#在屏幕上分页显示文件more.txt的内容</span><span class="token function">more</span> +3 more.txt <span class="token comment">#显示文件more.txt从第三行起的内容 </span><span class="token function">more</span> -5 more.txt <span class="token comment">#每屏显示5行内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>less命令：</strong></p><p>less命令的作用与more十分相似，都可以用来浏览文字档案的内容，相对于more命令来说更有弹 性，功能更多。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出<br>less程序，应按Q键。</p><p><strong>实例：</strong></p><p><code>less -N /etc/passwd #查看/etc/passwd文件并显示行号</code></p><ul><li><strong>文件编辑</strong></li></ul><p><strong>vi命令</strong></p><p>vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。Linux中的vi编辑器叫 vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。</p><p><strong>常用内置命令</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl+u：向文件首翻半屏； Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏； Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式； ZZ：命令模式下保存当前文件所做的修改后退出vi；:<span class="token punctuation">(</span>命令<span class="token punctuation">)</span> 可以输入一些命令，:q！ 可以不保存退出。:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首； x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符； dd：删除光标行正行内容； ndd：删除当前行及其后n-1行； p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方； P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方； /字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容；a：在当前字符后添加文本； A：在行末添加文本； i：在当前字符前插入文本； I：在行首插入文本；o：在当前行后面插入一空行；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>sed命令：</strong></p><p>sed是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用。处理时，把当前处理的行存储在临时缓冲区中，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><p><strong>命令格式：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">'command'</span> file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token function">sed</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> -f scriptfile file<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将file中的字符串book替换为books并输出，但不修改原文件</span><span class="token function">sed</span> <span class="token string">'s/book/books/'</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>文件过滤</strong></li></ul><p><strong>grep命令</strong>：</p><p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在文件中搜索一个单词，命令会返回一个包含"match_pattern"的文本行</span><span class="token function">grep</span> match_pattern file_name <span class="token function">grep</span> <span class="token string">"match_pattern"</span> file_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>文件压缩与解压</strong></li></ul><p><strong>tar命令</strong>：</p><p>tar命令可以为linux的文件和目录创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，或者将一个打包文件还原成若干文件。<br><code>tar [选项] [生成的新文件] [待打包压缩文件]</code></p><p><strong>常用选项：</strong></p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>-c</td><td>新建打包文件，同 -v 一起使用 查看过程中打包文件名</td></tr><tr><td>-x</td><td>解压文件， -c 解压到对应的文件目录。</td></tr><tr><td>-f</td><td>后面接要处理的文件</td></tr><tr><td>-j</td><td>通过bzip2方式压缩或解压，最后以.tar.br2 为后缀</td></tr><tr><td>-z</td><td>通过gzip方式压缩或解压，最后以.tar.gz 为后缀</td></tr><tr><td>-v</td><td>压缩或解压过程中，显示出来过程</td></tr></tbody></table><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将文件全部打包成tar包</span><span class="token function">tar</span> -cvf log.tar log2012.log <span class="token comment">#仅打包，不压缩！ </span><span class="token function">tar</span> -zcvf log.tar.gz log2012.log <span class="token comment">#打包后，以 gzip 压缩 </span><span class="token function">tar</span> -jcvf log.tar.bz2 log2012.log <span class="token comment">#打包后，以 bzip2 压缩</span><span class="token comment">#将tar包解压缩</span><span class="token function">tar</span> -zxvf /opt/soft/test/log.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>文件权限属性设置</li></ul><p><strong>stat命令：</strong></p><p>stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。</p><p><strong>选项：</strong></p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-L：支持符号连接； -f：显示文件系统状态而非文件状态； -t：以简洁方式输出信息； --help：显示指令的帮助信息；--version：显示指令的版本信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># stat myfile </span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># stat -f myfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>切换目录、盘符</strong></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>:<span class="token punctuation">\</span><span class="token punctuation">[</span>folderName<span class="token punctuation">]</span><span class="token builtin class-name">cd</span> / <span class="token comment">#切换到根目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>查看网卡</strong></li></ul><p><code>ifconfig</code></p><ul><li><strong>查看当前位置</strong></li></ul><p><code>pwd#查看当前目录位置</code></p><ul><li><strong>系统安全</strong></li></ul><p><strong>last、lastb命令：</strong></p><p>last命令用于显示用户最近登录信息。单独执行last命令，它会读取/var/log/wtmp的文件，并把 该文件的内容记录的登入系统的用户名单全部显示出来。</p><p>lastb命令用于显示用户错误的登录列表，此指令可以发现系统的登录异常。单独执行lastb命令， 它会读取位于/var/log目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，<br>全部显示出来。</p><p><strong>选项：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-a：把从何处登入系统的主机名称或ip地址，显示在最后一行； -d：将IP地址转换成主机名称； -f <span class="token operator">&lt;</span>记录文件<span class="token operator">&gt;</span>：指定记录文件。 -n <span class="token operator">&lt;</span>显示列数<span class="token operator">&gt;</span>或-<span class="token operator">&lt;</span>显示列数<span class="token operator">&gt;</span>：设置列出名单的显示列数； -R：不显示登入系统的主机名称或IP地址；-x：显示系统关机，重新开机，以及执行等级的改变等信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例：</strong></p><p><code>last -10</code></p><p><strong>w命令：</strong></p><p>w命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前 登入系统的用户有那些人，以及他们正在执行的程序。单独执行w命令会显示所有的用户，您也可<br>指定用户名称，仅显示某位用户的相关信息。</p><p><strong>选项：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-h：不打印头信息； -u：当显示当前进程和cpu时间时忽略用户名； -s：使用短输出格式； -f：显示用户从哪登录；-V：显示版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>进程和作业管理</strong></li></ul><p><strong>ps命令</strong></p><p>ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态 、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。</p><p><strong>选项：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-e 显示所有进程。-f 全格式。-h 不显示标题。-l 长格式。-w 宽输出。a 显示终端上的所有进程，包括其他用户的进程。r 只显示正在运行的进程。x 显示没有控制终端的进程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -aux <span class="token function">ps</span> -ef<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">less</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-系统服务"><a href="#2-2-2-系统服务" class="headerlink" title="2.2.2 系统服务"></a>2.2.2 系统服务</h3><h3 id="2-2-3-系统权限"><a href="#2-2-3-系统权限" class="headerlink" title="2.2.3 系统权限"></a>2.2.3 系统权限</h3><h1 id="三、WEB基础"><a href="#三、WEB基础" class="headerlink" title="三、WEB基础"></a>三、WEB基础</h1><h2 id="3-1-Web服务构成"><a href="#3-1-Web服务构成" class="headerlink" title="3.1 Web服务构成"></a>3.1 Web服务构成</h2><h3 id="3-1-1-了解web架构"><a href="#3-1-1-了解web架构" class="headerlink" title="3.1.1 了解web架构"></a>3.1.1 了解web架构</h3><h3 id="3-1-2-了解web服务"><a href="#3-1-2-了解web服务" class="headerlink" title="3.1.2 了解web服务"></a>3.1.2 了解web服务</h3><h2 id="3-2-HTTP协议原理"><a href="#3-2-HTTP协议原理" class="headerlink" title="3.2 HTTP协议原理"></a>3.2 HTTP协议原理</h2><h3 id="3-2-1-了解HTTP请求方法"><a href="#3-2-1-了解HTTP请求方法" class="headerlink" title="3.2.1 了解HTTP请求方法"></a>3.2.1 了解HTTP请求方法</h3><h3 id="3-2-2-了解HTTP请求状态码"><a href="#3-2-2-了解HTTP请求状态码" class="headerlink" title="3.2.2 了解HTTP请求状态码"></a>3.2.2 了解HTTP请求状态码</h3><h3 id="3-2-3-了解HTTP请求、响应头部"><a href="#3-2-3-了解HTTP请求、响应头部" class="headerlink" title="3.2.3 了解HTTP请求、响应头部"></a>3.2.3 了解HTTP请求、响应头部</h3><h2 id="3-3-Web日志分析方法"><a href="#3-3-Web日志分析方法" class="headerlink" title="3.3 Web日志分析方法"></a>3.3 Web日志分析方法</h2><h3 id="3-3-1-了解Web日志分析基础知识"><a href="#3-3-1-了解Web日志分析基础知识" class="headerlink" title="3.3.1 了解Web日志分析基础知识"></a>3.3.1 了解Web日志分析基础知识</h3><h1 id="四、安全漏洞基础"><a href="#四、安全漏洞基础" class="headerlink" title="四、安全漏洞基础"></a>四、安全漏洞基础</h1><h3 id="4-1-Web-TOP10-漏洞"><a href="#4-1-Web-TOP10-漏洞" class="headerlink" title="4.1 Web TOP10 漏洞"></a>4.1 Web TOP10 漏洞</h3><h1 id="五、标准应急响应"><a href="#五、标准应急响应" class="headerlink" title="五、标准应急响应"></a>五、标准应急响应</h1><h2 id="5-1-流程规范"><a href="#5-1-流程规范" class="headerlink" title="5.1 流程规范"></a>5.1 流程规范</h2><h3 id="5-1-1-了解应急响应标准概念及分类"><a href="#5-1-1-了解应急响应标准概念及分类" class="headerlink" title="5.1.1 了解应急响应标准概念及分类"></a>5.1.1 了解应急响应标准概念及分类</h3><h3 id="5-1-2-了解应急响应处理流程"><a href="#5-1-2-了解应急响应处理流程" class="headerlink" title="5.1.2 了解应急响应处理流程"></a>5.1.2 了解应急响应处理流程</h3><h3 id="5-1-3-掌握应急响应报告编写"><a href="#5-1-3-掌握应急响应报告编写" class="headerlink" title="5.1.3 掌握应急响应报告编写"></a>5.1.3 掌握应急响应报告编写</h3><h2 id="5-2-web应用应急响应"><a href="#5-2-web应用应急响应" class="headerlink" title="5.2 web应用应急响应"></a>5.2 web应用应急响应</h2><h3 id="5-2-1-Web-正常工作及入侵流程"><a href="#5-2-1-Web-正常工作及入侵流程" class="headerlink" title="5.2.1 Web 正常工作及入侵流程"></a>5.2.1 Web 正常工作及入侵流程</h3><h3 id="5-2-2-Webshell-安全事件及其应急处理"><a href="#5-2-2-Webshell-安全事件及其应急处理" class="headerlink" title="5.2.2 Webshell 安全事件及其应急处理"></a>5.2.2 Webshell 安全事件及其应急处理</h3><h3 id="5-2-3-黑链安全事件及其应急处理"><a href="#5-2-3-黑链安全事件及其应急处理" class="headerlink" title="5.2.3 黑链安全事件及其应急处理"></a>5.2.3 黑链安全事件及其应急处理</h3><h3 id="5-2-4-Web-日志分析"><a href="#5-2-4-Web-日志分析" class="headerlink" title="5.2.4 Web 日志分析"></a>5.2.4 Web 日志分析</h3><h2 id="5-3-Win系统应急响应"><a href="#5-3-Win系统应急响应" class="headerlink" title="5.3 Win系统应急响应"></a>5.3 Win系统应急响应</h2><h3 id="5-3-1-Windows-病毒概念"><a href="#5-3-1-Windows-病毒概念" class="headerlink" title="5.3.1 Windows 病毒概念"></a>5.3.1 Windows 病毒概念</h3><h3 id="5-3-2-Windows-病毒查杀"><a href="#5-3-2-Windows-病毒查杀" class="headerlink" title="5.3.2 Windows 病毒查杀"></a>5.3.2 Windows 病毒查杀</h3><h3 id="5-3-3-Windows-系统日志分析"><a href="#5-3-3-Windows-系统日志分析" class="headerlink" title="5.3.3 Windows 系统日志分析"></a>5.3.3 Windows 系统日志分析</h3><h3 id="5-3-4-windows-应急响应入侵排查思路介绍"><a href="#5-3-4-windows-应急响应入侵排查思路介绍" class="headerlink" title="5.3.4 windows 应急响应入侵排查思路介绍"></a>5.3.4 windows 应急响应入侵排查思路介绍</h3><h3 id="5-3-5-临时处置方案"><a href="#5-3-5-临时处置方案" class="headerlink" title="5.3.5 临时处置方案"></a>5.3.5 临时处置方案</h3><h3 id="5-3-6-日志分析，事件处置"><a href="#5-3-6-日志分析，事件处置" class="headerlink" title="5.3.6 日志分析，事件处置"></a>5.3.6 日志分析，事件处置</h3><h2 id="5-4-Linux-系统应急响应"><a href="#5-4-Linux-系统应急响应" class="headerlink" title="5.4 Linux 系统应急响应"></a>5.4 Linux 系统应急响应</h2><h3 id="5-4-1-Linux-病毒概念"><a href="#5-4-1-Linux-病毒概念" class="headerlink" title="5.4.1 Linux 病毒概念"></a>5.4.1 Linux 病毒概念</h3><h3 id="5-4-2Linux-病毒查杀"><a href="#5-4-2Linux-病毒查杀" class="headerlink" title="5.4.2Linux 病毒查杀"></a>5.4.2Linux 病毒查杀</h3><h3 id="5-4-3-Linux-系统日志分析"><a href="#5-4-3-Linux-系统日志分析" class="headerlink" title="5.4.3 Linux 系统日志分析"></a>5.4.3 Linux 系统日志分析</h3><h3 id="5-4-4-Linux-应急响应入侵排查思路介绍"><a href="#5-4-4-Linux-应急响应入侵排查思路介绍" class="headerlink" title="5.4.4 Linux 应急响应入侵排查思路介绍"></a>5.4.4 Linux 应急响应入侵排查思路介绍</h3><h3 id="5-4-5-Linux-异常分析排查"><a href="#5-4-5-Linux-异常分析排查" class="headerlink" title="5.4.5 Linux 异常分析排查"></a>5.4.5 Linux 异常分析排查</h3><h3 id="5-4-6-Linux-进程所对文件分析"><a href="#5-4-6-Linux-进程所对文件分析" class="headerlink" title="5.4.6 Linux 进程所对文件分析"></a>5.4.6 Linux 进程所对文件分析</h3><h2 id="5-5-常见病毒处置案例"><a href="#5-5-常见病毒处置案例" class="headerlink" title="5.5 常见病毒处置案例"></a>5.5 常见病毒处置案例</h2><h3 id="5-5-1-勒索挖矿病毒处置步骤"><a href="#5-5-1-勒索挖矿病毒处置步骤" class="headerlink" title="5.5.1 勒索挖矿病毒处置步骤"></a>5.5.1 勒索挖矿病毒处置步骤</h3><h3 id="5-5-2-勒索挖矿病毒加固建议"><a href="#5-5-2-勒索挖矿病毒加固建议" class="headerlink" title="5.5.2 勒索挖矿病毒加固建议"></a>5.5.2 勒索挖矿病毒加固建议</h3><h1 id="六、安全运维"><a href="#六、安全运维" class="headerlink" title="六、安全运维"></a>六、安全运维</h1><h2 id="6-1-TCE-安全产品介绍"><a href="#6-1-TCE-安全产品介绍" class="headerlink" title="6.1 TCE 安全产品介绍"></a>6.1 TCE 安全产品介绍</h2><ul><li>了解TCE常用安全产品的原理和使用</li></ul><h2 id="6-2-服态势感知产品分析"><a href="#6-2-服态势感知产品分析" class="headerlink" title="6.2 服态势感知产品分析"></a>6.2 服态势感知产品分析</h2><ul><li>了解态势感知产品日志检测分析</li></ul><h2 id="6-3-风险评估"><a href="#6-3-风险评估" class="headerlink" title="6.3 风险评估"></a>6.3 风险评估</h2><h3 id="6-3-1-风险评估概述"><a href="#6-3-1-风险评估概述" class="headerlink" title="6.3.1 风险评估概述"></a>6.3.1 风险评估概述</h3><h3 id="6-3-2-风险评估工作形式"><a href="#6-3-2-风险评估工作形式" class="headerlink" title="6.3.2 风险评估工作形式"></a>6.3.2 风险评估工作形式</h3><h3 id="6-3-3-风险评估方法"><a href="#6-3-3-风险评估方法" class="headerlink" title="6.3.3 风险评估方法"></a>6.3.3 风险评估方法</h3><h3 id="6-3-4-风险评估实施流程"><a href="#6-3-4-风险评估实施流程" class="headerlink" title="6.3.4 风险评估实施流程"></a>6.3.4 风险评估实施流程</h3><h3 id="6-3-5-风险评估工具"><a href="#6-3-5-风险评估工具" class="headerlink" title="6.3.5 风险评估工具"></a>6.3.5 风险评估工具</h3><h3 id="6-3-6-资产梳理"><a href="#6-3-6-资产梳理" class="headerlink" title="6.3.6 资产梳理"></a>6.3.6 资产梳理</h3><h2 id="6-4-重要时期安全保障"><a href="#6-4-重要时期安全保障" class="headerlink" title="6.4 重要时期安全保障"></a>6.4 重要时期安全保障</h2><h3 id="6-4-1-网络安全攻防演练基础"><a href="#6-4-1-网络安全攻防演练基础" class="headerlink" title="6.4.1 网络安全攻防演练基础"></a>6.4.1 网络安全攻防演练基础</h3><h3 id="6-4-2-网络安全攻防演练进阶"><a href="#6-4-2-网络安全攻防演练进阶" class="headerlink" title="6.4.2 网络安全攻防演练进阶"></a>6.4.2 网络安全攻防演练进阶</h3><h3 id="6-4-3-操作系统加固"><a href="#6-4-3-操作系统加固" class="headerlink" title="6.4.3 操作系统加固"></a>6.4.3 操作系统加固</h3><h3 id="6-4-4-中间件加固"><a href="#6-4-4-中间件加固" class="headerlink" title="6.4.4 中间件加固"></a>6.4.4 中间件加固</h3><h2 id="6-5-渗透测试"><a href="#6-5-渗透测试" class="headerlink" title="6.5 渗透测试"></a>6.5 渗透测试</h2><h3 id="6-5-1-渗透测试基础"><a href="#6-5-1-渗透测试基础" class="headerlink" title="6.5.1 渗透测试基础"></a>6.5.1 渗透测试基础</h3><h3 id="6-5-2-信息收集技术"><a href="#6-5-2-信息收集技术" class="headerlink" title="6.5.2 信息收集技术"></a>6.5.2 信息收集技术</h3><h3 id="6-5-3-常见渗透技术"><a href="#6-5-3-常见渗透技术" class="headerlink" title="6.5.3 常见渗透技术"></a>6.5.3 常见渗透技术</h3><h2 id="6-6-项目交付流程"><a href="#6-6-项目交付流程" class="headerlink" title="6.6 项目交付流程"></a>6.6 项目交付流程</h2><ul><li>安服项目交付流程</li><li>安服项目交付流程管理</li><li>安服项目案例</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝队面试题</title>
      <link href="/posts/ec466f09.html"/>
      <url>/posts/ec466f09.html</url>
      
        <content type="html"><![CDATA[<p>OCEAN’S 安全面试题整理系列文章：</p><ol><li><a class="link" href="https://blog.csdn.net/q20010619/article/details/124329818">渗透测试&amp;网络&amp;CTF面试题整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="https://blog.csdn.net/q20010619/article/details/124329764?spm=1001.2014.3001.5501">PHP&amp;Java&amp;Py&amp;漏洞利用or运维面试题整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="https://blog.csdn.net/q20010619/article/details/123185212">红队面试题整理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="https://blog.csdn.net/q20010619/article/details/123015066">蓝队面试题整理（含回答） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" href="https://github.com/Leezj9671/Pentest_Interview/blob/master/HR%E9%97%AE%E9%A2%98.md">HR问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ol><h1 id="🅰️应急响应🛡️"><a href="#🅰️应急响应🛡️" class="headerlink" title="🅰️应急响应🛡️"></a>🅰️应急响应🛡️</h1><h2 id="⬆️宏观题"><a href="#⬆️宏观题" class="headerlink" title="⬆️宏观题"></a>⬆️宏观题</h2><h3 id="1-基本思路流程"><a href="#1-基本思路流程" class="headerlink" title="1.基本思路流程"></a>1.基本思路流程</h3><ol><li>收集信息：收集客户信息和中毒主机信息，包括样本</li><li>判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等</li><li>抑制范围：隔离使受害⾯不继续扩⼤</li><li>深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源</li><li>清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产</li><li>产出报告：整理并输出完整的安全事件报告</li></ol><h3 id="2-Windows入侵排查思路"><a href="#2-Windows入侵排查思路" class="headerlink" title="2.Windows入侵排查思路"></a>2.Windows入侵排查思路</h3><ol><li><p>检查系统账号安全</p><ol><li><p>查看服务器是否有弱口令，远程管理端口是否对公网开放（使用<code>netstat -ano </code>命令、或者问服务器管理员）</p></li><li><p><code>lusrmgr.msc </code>命令查看服务器是否存在可疑账号、新增账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉</p></li><li><p>用 D 盾或者注册表中查看服务器是否存在隐藏账号、克隆账号</p></li><li><p>结合日志，查看管理员登录时间、用户名是否存在异常</p><p>检查方法：Win+R 打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”，导出 Windows 日志–安全，利用 Log Parser 进行分析</p></li></ol></li><li><p>检查异常端口、进程</p><ol><li><code>netstat -ano</code>检查端口连接情况，是否有远程连接、可疑连接</li><li>任务管理器-进程</li></ol></li><li><p>检查启动项、计划任务、服务</p></li><li><p>检查系统相关信息</p><p>查看系统版本以及补丁信息</p><p>查找可疑目录及文件</p></li><li><p>日志分析</p></li></ol><h3 id="3-Linux入侵排查思路"><a href="#3-Linux入侵排查思路" class="headerlink" title="3.Linux入侵排查思路"></a>3.Linux入侵排查思路</h3><ol><li><p>账号安全</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">who</span>查看当前登录用户（tty本地登陆 pts远程登录）w 查看系统信息，想知道某一时刻用户的行为<span class="token function">uptime</span>查看登陆多久、多少用户，负载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>、用户信息文件/etc/passwdroot:x:0:0:root:/root:/bin/bashaccount:password:<span class="token environment constant">UID</span>:GID:GECOS:directory:shell用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell注意：无密码只允许本机登陆，远程不允许登陆<span class="token number">2</span>、影子文件/etc/shadowroot:<span class="token variable">$6</span><span class="token variable">$oGs1PqhL2p3ZetrE</span><span class="token variable">$X7o7bzoouHQVSEmSgsYN5UD4</span>.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>/etc/passwd</code> 存储一般的用户信息，任何人都可以访问；<code>/etc/shadow</code> 存储用户的密码信息，只有 root 用户可以访问</p></li><li><p>历史命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">通过 .bash_history 查看帐号执行过的系统命令<span class="token number">1</span>、root的历史命令 histroy<span class="token number">2</span>、打开 /home 各帐号目录下的 .bash_history，查看普通帐号的历史命令历史操作命令的清除：history -c但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查异常端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">netstat</span> -antlp<span class="token operator">|</span><span class="token function">more</span>查看下pid所对应的进程文件路径，运行ls -l /proc/<span class="token variable">$PID</span>/exe或file /proc/<span class="token variable">$PID</span>/exe（<span class="token variable">$PID</span> 为对应的pid 号）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>检查异常进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>检查开机启动项</p><p>开机启动配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/rc.local/etc/rc.d/rc<span class="token punctuation">[</span><span class="token number">0</span>~6<span class="token punctuation">]</span>.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>检查定时任务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">crontab</span> -l 列出某个用户cron服务的详细内容Tips：默认编写的crontab文件会保存在 <span class="token punctuation">(</span>/var/spool/cron/用户名 例如: /var/spool/cron/root<span class="token function">crontab</span> -r 删除每个用户cront任务<span class="token punctuation">(</span>谨慎：删除所有的计划任务<span class="token punctuation">)</span><span class="token function">crontab</span> -e 使用编辑器编辑当前的crontab文件如：*/1 * * * * <span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span> <span class="token operator">&gt;&gt;</span> /tmp/test.txt 每分钟写入文件<span class="token number">2</span>、利用anacron实现异步定时任务调度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点关注</p><pre class="line-numbers language-none"><code class="language-none">/var/spool/cron/*/etc/crontab/etc/cron.d/*/etc/cron.daily/*/etc/cron.hourly/*/etc/cron.monthly/*/etc/cron.weekly//etc/anacrontab/var/spool/anacron/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查服务</p><p>chkconfig –list 命令，可以查看系统运行的服务</p></li><li><p>检查异常文件</p></li><li><p>检查系统日志</p></li></ol><h3 id="Linux的登录日志查看文件"><a href="#Linux的登录日志查看文件" class="headerlink" title="Linux的登录日志查看文件"></a>Linux的登录日志查看文件</h3><ul><li>日志默认存放位置：/var/log/</li><li>查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’</li><li>查看所有用户最后的登录信息 lastlog</li><li>查看用户最近登录信息 last 其中，/var/log/wtmp 存储登录成功的信息、btmp 存储登录失败的信息、utmp 存储当前正在登录的信息</li><li>查看当前用户登录系统情况 who</li></ul><h3 id="Linux常用排查命令"><a href="#Linux常用排查命令" class="headerlink" title="Linux常用排查命令"></a>Linux常用排查命令</h3><p>这个问题就是 linux 入侵排查排查的一部分</p><p><a class="link" href="https://cloud.tencent.com/developer/article/1822210">https://cloud.tencent.com/developer/article/1822210 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>系统信息</p><ol><li>查看当前系统状态 top</li><li>操作系统信息 uname -a</li><li>查看当前系统进程信息 ps</li><li>查看历史命令 history</li><li>列出本机所有的连接和监听的端口 netstat</li><li>查看谁在使用某个端口 lsof</li></ol><p>用户登录</p><ol><li><p>查看当前用户登录系统情况 who</p></li><li><p>分析超级权限账户 awk-F： ‘{if（$3==0）print $1}’/etc/passwd</p></li><li><p>查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’</p></li><li><p>查看用户错误的登录信息 lastb</p></li><li><p>查看所有用户最后的登录信息 lastlog</p></li><li><p>查看用户最近登录信息 last</p><p>/var/log/ 其中，/var/log/wtmp 存储登录成功的信息、btmp存储登录失败的信息、utmp存储当前正在登录的信息</p></li><li><p>查看空口令账户 awk-F： ‘length（$2）==0 {print $1}’/etc/shadow</p></li></ol><h3 id="Linux基线规范"><a href="#Linux基线规范" class="headerlink" title="Linux基线规范"></a>Linux基线规范</h3><p>每个公司有每个公司的基线规范体系，但是答题分为下列五个方面</p><p><strong>账号管理和授权</strong></p><ul><li>检查特殊账号，是否存在空密码的账户和 root 权限账户</li><li>禁用或删除无用账号</li><li>添加口令策略:<code>/etc/login.defs</code>修改配置文件，设置过期时间、连续认证失败次数</li><li>禁止 root 远程登录，限制root用户直接登录。</li><li>检查 su 权限。<code>vi /etc/pam.d/su</code>添加<code>auth required pam_wheel.so group=test</code></li></ul><p><strong>服务</strong></p><ul><li>关闭不必要的服务</li><li>SSH 服务安全<ul><li>不允许 root 账号直接登录系统，<code>PermitRootLogin=no</code></li><li>修改 SSH 使用的协议版本为 2</li><li>修改允许密码错误次数（默认 6 次），<code>MaxAuthTries=3</code></li></ul></li></ul><p><strong>文件系统</strong></p><ul><li>设置 umask 值 <code>vi /etc/profile</code> 添加行 <code>umask 027</code></li><li>设置登录超时 <code>vi /etc/profile</code> 修改配置文件，将以 <code>TMOUT=</code> 开头的行注释，设置为 <code>TMOUT=180</code></li></ul><p><strong>日志</strong></p><ul><li><p>启用 syslogd 日志，配置日志目录权限，或者设置日志服务器</p></li><li><p>记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查</p><p><a class="link" href="https://www.alibabacloud.com/help/zh/faq-detail/49809.htm">https://www.alibabacloud.com/help/zh/faq-detail/49809.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><p><strong>IP 协议安全要求</strong></p><ul><li>远程登录取消 telnet 采用 ssh</li><li>设置 /etc/hosts.allow 和 deny</li><li>禁止 ICMP 重定向</li><li>禁止源路由转发</li><li>防 ssh 破解，iptables (对已经建立的所有链接都放行，限制每分钟连接 ssh 的次数)+ denyhost (添加 ip 拒绝访问)</li></ul><p><strong>Linux 安全基线检查</strong></p><p>Linux：<a class="link" href="https://cloud.tencent.com/developer/article/1668982">https://cloud.tencent.com/developer/article/1668982 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="Windows-安全基线检查"><a href="#Windows-安全基线检查" class="headerlink" title="Windows 安全基线检查"></a>Windows 安全基线检查</h3><p>Windows：<a class="link" href="https://cloud.tencent.com/developer/article/1668937">https://cloud.tencent.com/developer/article/1668937 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>主要包括五个方面：身份鉴别、访问控制、安全审计、资源控制、剩余信息保护</p><ul><li><p><strong>身份鉴别</strong></p><p>更改缺省账户</p><p>检查Guest用户是否禁用</p><p>密码复杂性要求</p><p>密码长度最小不能小于8位</p></li><li><p><strong>访问控制</strong></p><p>共享账户检查</p><p>远程关机授权</p><p>本地关机</p><p>授权帐户登陆</p></li><li><p><strong>安全审计</strong></p><p>用户登录日志记录</p><p>系统日志完备性检查</p><p>登录超时管理</p></li><li><p><strong>资源控制</strong></p><p>登录超时管理</p><p>远程登录超时配置</p></li><li><p><strong>剩余信息保护</strong></p><p>不显示上次的用户名</p><p>关机前清除虚拟内存页面</p><p>不启用可还原的加密来存储密码</p></li></ul><h3 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h3><blockquote><p><a class="link" href="https://www.alibabacloud.com/help/zh/faq-detail/52981.htm">https://www.alibabacloud.com/help/zh/faq-detail/52981.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><p>配置</p><ul><li>账号</li><li>授权</li><li>日志</li><li>session 过期时间（防ddos）</li><li>绑定监听地址</li></ul><p>禁止</p><ul><li>目录权限</li><li>访问外部文件</li><li>CGI</li><li>非法HTTP方法（PUT DELETE）</li></ul><p>隐藏</p><ul><li>服务版本号</li><li>重定向错误页面</li></ul><p>删除</p><ul><li>配置文件</li><li>默认安装的无用文件</li></ul><h3 id="中间件常见漏洞"><a href="#中间件常见漏洞" class="headerlink" title="中间件常见漏洞"></a>中间件常见漏洞</h3><p><a class="link" href="https://www.freebuf.com/articles/web/192063.html">https://www.freebuf.com/articles/web/192063.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>（一） IIS</strong><br>1、PUT漏洞</p><p>2、短文件名猜解</p><p>3、远程代码执行</p><p>4、解析漏洞</p><p><strong>（二） Apache</strong><br>1、解析漏洞</p><p>2、目录遍历</p><p><strong>（三） Nginx</strong><br>1、文件解析</p><p>2、目录遍历</p><p>3、CRLF注入</p><p>4、目录穿越</p><p><strong>（四）Tomcat</strong><br>1、远程代码执行</p><p>2、war后门文件部署</p><p><strong>（五）jBoss</strong><br>1、反序列化漏洞</p><p>2、war后门文件部署</p><p><strong>（六）WebLogic</strong><br>1、反序列化漏洞</p><p>2、SSRF</p><p>3、任意文件上传</p><p>4、war后门文件部署</p><p><strong>（七）其它中间件相关漏洞</strong><br>1、FastCGI未授权访问、任意命令执行</p><p>2、PHPCGI远程代码执行</p><h3 id="Linux、Windows安全加固"><a href="#Linux、Windows安全加固" class="headerlink" title="Linux、Windows安全加固"></a>Linux、Windows安全加固</h3><p><strong>IIS 服务器应该做哪些方面的保护措施？</strong></p><p>整理来源：<a class="link" href="http://www.williamlong.info/archives/118.html">http://www.williamlong.info/archives/118.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol><li>保持 Windows 升级</li><li>使用 IIS 防范工具</li><li>移除缺省的 Web 站点</li><li>如果你并不需要 FTP 和 SMTP 服务，请卸载它们</li><li>有规则地检查你的管理员组和服务:</li><li>严格控制服务器的写访问权限</li><li>设置复杂的密码</li><li>减少/排除 Web 服务器上的共享</li><li>禁用 TCP/IP 协议中的 NetBIOS</li><li>使用 TCP 端口阻塞</li><li>仔细检查 .bat 和 .exe 文件：每周搜索一次 .bat</li><li>管理 IIS 目录安全</li><li>使用 NTFS 安全</li><li>管理用户账户</li><li>审计你的 Web 服务器</li></ol><p><strong>Linux系统安全加固需要注意的内容</strong></p><ol><li>关闭不必要的系统服务</li><li>更改 SSH 默认端口</li><li>禁止 root 用户远程 ssh 登录</li><li>限制用户使用 su 命令切换 root</li><li>密码复杂度策略</li><li>检查密码重复使用次数限制</li><li>检查是否存在空口令账号</li><li>禁止同时按下 ctrl+alt+del 重启</li><li>禁用 telnet 服务</li></ol><h3 id="框架漏洞-amp-常见命令注入漏洞？php-Strust2"><a href="#框架漏洞-amp-常见命令注入漏洞？php-Strust2" class="headerlink" title="框架漏洞&amp;常见命令注入漏洞？php? Strust2 ?"></a>框架漏洞&amp;常见命令注入漏洞？php? Strust2 ?</h3><ul><li>Struts2 OGNL 注入</li><li>weblogic</li><li>fastjson</li><li>TP5 代码执行</li><li>laravel：debug mode 远程代码执行漏洞（CVE-2021-3129）</li><li>Spring Expression Language SPEL 表达式注入</li><li>Spring Security Oauth2 远程代码执行</li><li><a class="link" href="https://www.freebuf.com/articles/web/286666.html">Spring框架漏洞总结 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h3 id="常见安全工具、设备"><a href="#常见安全工具、设备" class="headerlink" title="常见安全工具、设备"></a>常见安全工具、设备</h3><p><strong>工具</strong></p><ul><li>端口及漏洞扫描：Namp、Masscan</li><li>抓包：Wireshark，Burpsuite、Fiddler、HttpCanary</li><li>Web自动化安全扫描：Nessus、Awvs、Appscan、Xray</li><li>信息收集：Oneforall、hole</li><li>漏洞利用：MSF、CS</li><li>Webshell 管理：菜刀、蚁剑、冰蝎、哥斯拉</li></ul><p><strong>设备</strong></p><p><a class="link" href="https://wiki.wgpsec.org/knowledge/base/safety.html">网络安全设备常识 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>常见的 HW 设备有：公安部网防G01、K01、360网康/网神防火墙、微步威胁情报、安恒云-Web应用防火墙（玄武盾）、默安蜜罐、知道创宇蜜罐、山石防火墙</p><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/ie4h5RDb9mOgKcZ.png" alt="image-20211224223800578"></p><p>即客户拥有物理的基础设施（自建机房、自购设备、网络）</p><ul><li><p>NGAF/NGFW：下一代 Web 应用防火墙（Next Generation Application Firewall，<a class="link" href="https://www.huaweicloud.com/zhishi/edit-582196.html">通防火墙和下一代防火墙的区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），聚合了以下功能</p><ul><li>IDS<ul><li>HIDS：基于主机的入侵检测系统</li><li>NIDS：基于网络的入侵检测系统</li><li>HIDS+NIDS：基于混合数据源的入侵检测系统</li></ul></li><li>IPS：入侵防御系统</li><li>AV：反病毒系统</li></ul></li><li><p>EDR：主机安全管理\终端检测和响应</p><p>EDR 实时监测终端上发生的各类行为，采集终端运行状态，在后端通过大数据安全分析、机器学习、沙箱分析、行为分析、机器学习等技术，提供深度持续监控、威胁检测、高级威胁分析、调查取证、事件响应处置、追踪溯源等功能，可第一时间检测并发现恶意活动，包括已知和未知威胁，并快速智能地做出响应，全面赋予终端主动、积极的安全防御能力</p><p>简单来说就是给内网环境中所有主机安装管理软件终端，可以在管理平台集中管理和数据分析过滤，基本所有安全厂商都有自己的 EDR 产品</p></li><li><p>运维审计和管理平台（堡垒机）</p></li><li><p>DAS：数据库安全审计平台</p></li><li><p>LAS：日志审计安全平台</p></li><li><p>AC：上网行为管理系统</p></li><li><p>伪装欺骗系统（蜜罐、蜜网）</p></li><li><p>SIP：安全态势感知平台</p><p>这个算是让整套系统性能得到提升的灵魂了，定位为客户的安全大脑，是一个集检测、可视、响应处置于一体的大数据安全分析平台。产品以大数据分析为核心，支持主流的安全设备、网络设备、操作系统等多源数据接入，利用大数据、关联分析、告警降噪等技术，实现海量数据的统一挖掘分析</p></li></ul><p><strong>云网络</strong></p><p>云网络包括私有云和公有云</p><ul><li>云主机安全</li><li>云防火墙</li><li>云堡垒机</li><li>云蜜罐</li><li>云 DDOS 防护</li><li>等等</li></ul><h3 id="绿盟设备"><a href="#绿盟设备" class="headerlink" title="绿盟设备"></a>绿盟设备</h3><ul><li>堡垒机 SAS-H Series，堡垒机采用“物理旁路，逻辑串联”的部署思路</li><li>绿盟威胁情报云 NTI <a class="link" href="https://nti.nsfocus.com/">https://nti.nsfocus.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>抗拒绝服务攻击系统 ADS</li><li>安全和漏洞管理 AIRO</li><li>网络入侵防护系统 IDPS</li><li>web 应用防火墙</li></ul><h3 id="你拿到的cnvd"><a href="#你拿到的cnvd" class="headerlink" title="你拿到的cnvd"></a>你拿到的cnvd</h3><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="**工作经历"></a>**工作经历</h3><p>安全服务工程师</p><p>参加渗透测试、地方服务、HW</p><p>根据客户方要求对所给资产进行了详细细致的渗透测试。挖掘漏洞，发现漏洞的第一时间与客户方汇报，使客户方能够及时整改修补问题漏洞，防止造成漏洞危害扩大</p><h3 id="攻防演练"><a href="#攻防演练" class="headerlink" title="攻防演练"></a>攻防演练</h3><p>攻防演练中担任什么角色</p><h3 id="护网的分组和流程？"><a href="#护网的分组和流程？" class="headerlink" title="护网的分组和流程？"></a>护网的分组和流程？</h3><p>护网的分组是在领导小组之下分为防护检测组，综合研判组，应急溯源组。流程大致分为备战，临战，决战三个阶段</p><p><strong>备战阶段</strong>，主要任务是进行两方面的操作，一是减少攻击面，即资产梳理，减少暴露面；二是排查风险点，即通过漏洞扫描，渗透测试，弱口令等进行自查</p><p><strong>临战阶段</strong>，主要任务也大致可以分为两个部分，一是进行内部演练，发现疏忽处并进行相应整改；二是可以适当增加安全设备，比如WAF，IPS，IDS，SOC，堡垒机等</p><p><strong>决战阶段</strong>，作为新人，主要就是坚守岗位，有应急日志就看自己能不能解决，不能就上报，服从上级安排，优化防护，持续整改</p><h3 id="简历有护网经历，你能谈谈护网的情况吗"><a href="#简历有护网经历，你能谈谈护网的情况吗" class="headerlink" title="简历有护网经历，你能谈谈护网的情况吗"></a>简历有护网经历，你能谈谈护网的情况吗</h3><p>参加过护网蓝队，负责事件研判工作，主要使用 ips，ids 等设备做流量监控与日志分析工作判断安全事件是否为误判</p><p>监控、研判、处置、溯源</p><p>对安全管理中心发出的态势排查单进行排查，并将排查结果反馈给安全管理中心，对安全管理中心发出的封堵工单和解封工单进行对应的封堵与解封，每两小时反馈一次排查结果、设备巡检报告、封堵情况。查看呼池 DDOS 设备，记录并排查告警信息</p><h3 id="蓝队研判"><a href="#蓝队研判" class="headerlink" title="蓝队研判"></a>蓝队研判</h3><p>研判工作要充分利用已有安全设备（需要提前了解客户的网络拓扑以及部署设备情况），分析其近期的设备告警，将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）根据研判标准进行筛选（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击</p><p>对于告警结合威胁情报库如：微步、奇安信威胁情报中心、<strong>绿盟威胁情报云</strong>等对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，推荐使用微步的插件，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为客户内网部署的设备，如果不是，继续进行下一步，在事件上报平台查看是否有其他人提交过，如果没有，则上报</p><p>然后根据流量日志，对请求数据包和返回数据包分析判断其是否为误报，需要留意 X-Forwarded-For（简称XFF）和 x-real-ip 可以了解些 webshell 工具的流量特征，尤其是免杀 webshell，有可能不会被设备识别</p><p>最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源</p><blockquote><p>注：不要任意忽略内网告警，适当情况下可以往前推排查时间</p></blockquote><h3 id="蓝队组成"><a href="#蓝队组成" class="headerlink" title="蓝队组成"></a>蓝队组成</h3><p>蓝队的主要工作包括前期安全检查、整改与加固，演习期间进行网络安全监测、预警、分析、验证、处置，后期复盘总结现有防护工作中的不足之处，为后续常态化的网络安全防护措施提供优化依据</p><p>监控、研判、处置、溯源</p><h3 id="SQL注入检测"><a href="#SQL注入检测" class="headerlink" title="SQL注入检测"></a>SQL注入检测</h3><p>SQL注入攻击检测可根据入侵事件发生的前后进行区分，在入侵前可以对 Payload 进行检测等方式以预防 SQL 注入攻击。在入侵检测后可以通过对数据库、IIS 日志等进行检查以进行判断</p><p>传统的SQL注入检测方法通常根据经验提取特征，然后基于规则库匹配的方法来检测是否为 SQL 注入语句，其设计一般较为复杂，且规则模式更新频繁，在此采用机器学习的方式尝试对 SQL 注入语句进行检测</p><h3 id="DDOS-CC应急思路以及如何防范"><a href="#DDOS-CC应急思路以及如何防范" class="headerlink" title="DDOS CC应急思路以及如何防范"></a>DDOS CC应急思路以及如何防范</h3><p>目前对于低网络层的 DDoS 攻击有一些有效的防护手段，如丢弃第一次 SYN 包，上流量防护设备，上 WAF 封禁地址等</p><p>比较难缠的是第七层，第八层的 CC 攻击，它会找到目标网站上比较消耗资源的关键位置，重复发起攻击以消耗 CPU/内存/数据库/IO 等资源，目前的应付手段有：</p><ol><li>优化资源消耗高位置的代码</li><li>增加硬件设备</li><li>上云</li><li>购买专业安全公司的安全服务</li><li>除此之外，隐藏服务器的真实 IP、上云 WAF、CDN、 负载均衡等设备，或者暂时将域名解析到公安网警网站等也是可以作为选择方案</li></ol><ul><li>网络设备设施<ul><li>拼带宽，加大带宽，但是成本太高</li><li>使用硬件防火墙</li><li>选用高性能设备</li></ul></li><li>抗 D 思想和方案<ul><li>负载均衡</li><li>花钱买流量清洗服务</li><li>CDN：web 层，比如 cc 攻击</li><li>分布式集群防御</li><li>高防：防大部分攻击，udp、大型的 cc 攻击</li></ul></li><li>预防为主<ul><li>系统漏洞</li><li>系统资源优化</li><li>过滤不必要的服务和端口</li><li>限制特定流量：检查访问来源做适当限制</li></ul></li></ul><h3 id="挖矿病毒判断-amp-挖矿常见手段-amp-处理"><a href="#挖矿病毒判断-amp-挖矿常见手段-amp-处理" class="headerlink" title="挖矿病毒判断&amp;挖矿常见手段&amp;处理"></a>挖矿病毒判断&amp;挖矿常见手段&amp;处理</h3><p><a class="link" href="https://zhuanlan.zhihu.com/p/139019250">挖矿病毒，自己搜搜 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>挖矿木马占用系统资源进行挖矿行为，一般电脑会有以下特征</p><ol><li>系统响应缓慢</li><li>CPU/显卡使用率过高</li><li>内存/带宽占用高</li></ol><p>登录进可疑主机后，可以通过以下方式确认挖矿木马（即入侵排查流程）</p><ol><li>查看进程（系统命令 ps、Is 有可能被替换）</li><li>检查日志、检查系统用户</li><li>发现异常文件</li></ol><p><strong>挖矿常用手段</strong></p><ol><li>未授权访问或弱口令：Redis 未授权访问、Docker API 未授权访问、Hadoop Yarn 未授权访问、NFS 未授权访问、Rsync 弱口令、PostgreSQL 弱口令、Tomcat 弱口令、SSH 弱口令、Telnet 弱口令、Windows 远程桌面弱口令</li><li>远程命令执行漏洞：WebLogic XML 反序列化漏洞、Jenkins 反序列化、Jboss 远程代码执行、Spring 远程代码执行、ElasticSearch 命令执行、永恒之蓝、Struts2 系列漏洞、常见 CMS 的远程命令执行漏洞</li><li>新爆的高危漏洞：一般每次爆发新的高危漏洞，都会紧跟一波大规模的全网扫描利用和挖矿</li></ol><p><strong>清除挖矿木马</strong></p><p><strong>原因排查</strong></p><p>一旦发现服务器被挖矿，应该首先查看挖矿进程所属的用户，根据挖矿进程的运行用户去排查该用户下是否还运行着其它进程，确定这些进程是否有上述经常被黑客利用的漏洞。如果有常见的漏洞，则应该重点对此进行排查找到原因</p><p><strong>清除木马</strong></p><ol><li><p>及时隔离主机</p><p>部分带有蠕虫功能的挖矿木马在取得本机的控制权后，会以本机为跳板机，对同一局域网内的其他主机进行已知漏洞的扫描和进一步利用， 所以发现挖矿现象后，在不影响业务的前提下应该及时隔离受感染主机，然后进行下一步分析</p></li><li><p>删除文件、阻断与矿池通讯</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">iptables -A INPUT -S xmr.crypto- pool.fr -j DROPiptables -A OUTPUT -d xmr.crypto- pool.fr -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>清除定时任务</p><p>大部分挖矿进程会在受感染主机中写入定时任务来完成程序的驻留，当安全人员只清除挖矿木马时，定时任务会再次从服务器下载挖矿进程或者直接执行挖矿脚本，导致挖矿进程清除失败</p></li><li><p>清除启动项</p><p>有的挖矿进程为了实现长期驻留，会向系统中添加启动项来确保系统重启后挖矿进程还能重新启动，所以在清除时还应该关注启动项中的内容如果有可疑的启动项，也应该进行排查，确认是挖矿进程后，对其进行清除</p></li><li><p>kill 挖矿进程</p><p>对于单进程挖矿程序，直接结束挖矿进程即可。但是对于大多数的挖矿进程，如果挖矿进程有守护进程，应先杀死守护进程再杀死挖矿进程，避免清除不彻底<br>在实际的清除工作中，应找到本机上运行的挖矿脚本，根据脚本的执行流程确定木马的驻留方式， 并按照顺序进行清除， 避免清除不彻底</p></li><li><p>清除公钥文件</p><p>在用户 home 目录的 .ssh 目录下放置 authoruzed_keys 文件，从而免密登录该机器也是一种常见的保持服务器控制权的手段。在排查过程中应该查看该文件中是否有可疑公钥信息，有的话直接删除，避免攻击者再次免密登录该主机</p></li></ol><h3 id="服务器存在webshell，如何处理？"><a href="#服务器存在webshell，如何处理？" class="headerlink" title="服务器存在webshell，如何处理？"></a>服务器存在webshell，如何处理？</h3><p>网站被植入 webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入 webshell 接管网站的控制权</p><ol><li>及时隔离主机</li><li>定位事件范围，查看文件 webshell 文件的创建时间，对 webshell 取证样本</li><li>通过创建时间结合日志分析可疑行为，以及启动用户的其他进程确定漏洞</li><li>清除 webshell 及残留文件，修复漏洞，参考上题</li></ol><h3 id="排查-shell-应该用什么命令来进行排查"><a href="#排查-shell-应该用什么命令来进行排查" class="headerlink" title="排查 shell 应该用什么命令来进行排查"></a>排查 shell 应该用什么命令来进行排查</h3><p>find 命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/www/html -name <span class="token string">"*.php"</span> <span class="token operator">|</span><span class="token function">xargs</span> <span class="token function">egrep</span> <span class="token string">'assert|eval|phpinfo\(\)|\(base64_decoolcode|shell_exec|passthru|file_put_contents\(\.\*\$|base64_decode\('</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="如何检测webshell"><a href="#如何检测webshell" class="headerlink" title="如何检测webshell"></a>如何检测webshell</h3><p><strong>主机层面</strong></p><ul><li><p>静态检测</p><p>静态检测通过匹配特征码，特征值，危险函数函数来查找 webshell 的方法，只能查找已知的 webshell</p></li><li><p>动态检测</p><p>webshell 传到服务器了，在执行函数时这些对于系统调用、系统配置、数据库、文件的操作动作都是可以作为判断依据</p></li><li><p>日志检测</p><p>使用 webshell 一般不会在系统日志中留下记录，但是会在网站的 web 日志中留下 webshell 页面的访问数据和数据提交记录</p></li><li><p>语法检测</p><p>语法语义分析形式，是根据 php 语言扫描编译的实现方式，进行剥离代码、注释，分析变量、函数、字符串、语言结构的分析方式，来实现关键危险函数的捕捉方式这样可以完美解决漏报的情况但误报上</p></li></ul><p><strong>流量层面</strong></p><h3 id="Webshell管理工具的流量特征"><a href="#Webshell管理工具的流量特征" class="headerlink" title="Webshell管理工具的流量特征"></a>Webshell管理工具的流量特征</h3><p><a class="link" href="https://www.freebuf.com/articles/web/213905.html">冰蝎动态二进制加密WebShell特征分析 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link" href="https://www.freebuf.com/column/204796.html">常见WebShell客户端的流量特征及检测思路 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>菜刀</strong></p><p>菜刀 webshell 只使用了 url 编码 + base64 编码</p><p>shell 特征就是传输参数名为 z0，还存在<code>int_set("display_erros","0")</code>字符串特征</p><p><strong>蚁剑</strong></p><p>默认的蚁剑 shell，连接时会请求两次，其请求体只是经过 url 编码，其流量中也存在和蚁剑一样的代码</p><p>第一次请求，关闭报错和 magic_quotes，接下来去获取主机的信息</p><p>第二次请求，会把主机目录列出来</p><p><strong>冰蝎2.0</strong></p><p>使用 aes 加密发起三次请求</p><p>第一次请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的</p><p>第二次请求是为了获取 key，第三次使用 key 的 aes 加密进行通信</p><p><strong>冰蝎3.0</strong></p><p>使用 aes 加密发起两次请求</p><p>3.0 分析流量发现相比 2.0 少了动态密钥的获取的请求，不再使用随机生成 key，改为取连接密码的 md5 加密值的前 16 位作为密钥</p><p>一次请求为判断是否可以建立连接，少了俩次 get 获取冰蝎动态密钥的行为，第二次发送 phpinfo 等代码执行，获取网站的信息</p><p><strong>哥斯拉</strong></p><p>支持 n 种加密</p><p>采用了和冰蝎 3.0 一样的密钥交换方式，哥斯拉建立连接时会发起三次请求，第一次请求数据超级长，建立 session，第二三次请求确认连接</p><h3 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h3><p><strong>数据库类（扫描弱口令）</strong></p><ul><li>1433：MSSQL</li><li>1521：Oracle</li><li>3306：Mysql</li><li>5432：PostgreSQL</li></ul><p><strong>特殊服务类（未授权/命令执行）</strong></p><ul><li>443：ssl 心脏滴血</li><li>873：Rsync 未授权</li><li>5984：CouchDB http：//xxx:5984/_utils/</li><li>6379：Redis 未授权</li><li>7001、7002：Weblogic 默认弱口令</li><li>8088：Hadoop Yarn 资源管理系统 REST API 存在未授权</li><li>8161：Apache ActiveMQ 未授权、弱口令，put 文件上传，move 文件移动</li><li>9200、9300：elasticsearch 命令执行</li><li>11211：Memcache 未授权，telnet ip 就可以获得服务器敏感信息</li><li>27017、27018：Mongodb 未授权</li><li>50000：SAP 命令执行</li><li>50070、50030 Hadoop 未授权访问</li></ul><p><strong>常用端口类（弱口令/端口爆破）</strong></p><ul><li>21：FTP 弱口令，匿名 anonymous/空登录，以及 ms12-073</li><li>25：SMTP 简单邮件传输服务器端口</li><li>23：Telnet 的端口，Telnet 是一种可以远程登录并管理远程机器的服务</li><li>22：ssh 端口，PcAnywhere 建立 TCP 和这一端口的连接可能是为了寻找 ssh，这一服务有许多弱点</li><li>53：dns 端口</li><li>139：属于 TCP 协议，是为 NetBIOS Session Service 提供的，主要提供 Windows 文件和打印机共享以及 Unix 中的 Samba 服务</li><li>445：网络共享 smb 服务，尝试利用 ms08067，ms17010 等以及 IPC$ 攻击手段</li><li>2601、2604：zebra 路由，默认密码 zebra</li></ul><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p><a class="link" href="https://www.eet-china.com/mp/a44399.html">https://www.eet-china.com/mp/a44399.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>背景：TCP 位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP 协议采纳三次握手四次挥手策略</p><p><strong>三次握手（three-way handshaking）</strong></p><p>TCP 三次握手，其实就是 TCP 应用在发送数据前，通过 TCP 协议跟通信对方协商好连接信息，建立起 TCP 的连接关系</p><ol><li>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认</li><li>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态</li><li>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手</li></ol><p><strong>四次挥手（Four-Way-Wavehand）</strong></p><p>当我们的应用程序不需要数据通信了，就会发起断开 TCP 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手</p><ol><li>第一次挥手：客户端发送一个 <code>FIN</code>，用来关闭客户端到服务端的数据传送，客户端进入 <code>FIN_WAIT_1</code> 状态</li><li>第二次挥手：服务端收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给客户端，确认序号为收到序号 +1（与SYN相同，一个FIN占用一个序号），服务端进入 <code>CLOSE_WAIT</code> 状态</li><li>第三次挥手：服务端发送一个 <code>FIN</code>，用来关闭服务端到 客户端的数据传送，服务端进入 <code>LAST_ACK</code> 状态</li><li>第四次挥手：客户端收到 <code>FIN</code> 后，客户端进入 <code>TIME_WAIT</code> 状态，接着发送一个 <code>ACK</code> 给服务端，确认序号为收到序号 +1，服务端进入 <code>CLOSED</code> 状态，完成四次挥手</li></ol><h3 id="一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理-★★"><a href="#一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理-★★" class="headerlink" title="一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理(★★)"></a>一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理(★★)</h3><ol><li>首先是评估 0day 对自身系统的影响（这部分评估需要根据漏洞利用的利用点、是否需要交互、是否会影响系统的 CIA，是否有在野利用 poc，影响资产是否暴露在公网等很多因素决定，详情可以参考 CVSS ）</li><li>如果确定有影响的话且有 poc，第一件事是先分析 poc 执行后会在什么地方留下痕迹，我们有什么样的设备去采集这些痕迹所留下的数据，比如说 ntlm relay 这种，可以考虑从 Windows 事件日志当中 event_id 等于 4769 的事件入手编写对应的规则，这样的话可以利用 SIEM 或者实时日志分析平台跑起来，可以建立起初步的感知防线，后期触发告警，人肉运营也可以快速止损</li><li>日常建立完整的纵深防御体系，不要依赖于某一道防线</li></ol><h3 id="服务器操作系统的安全防范？"><a href="#服务器操作系统的安全防范？" class="headerlink" title="服务器操作系统的安全防范？"></a>服务器操作系统的安全防范？</h3><ol><li>停止运行不需要的软件（很可能成为外部攻击的入口）</li><li>定期实施漏洞防范措施（选定软件时确认软件的升级状况，确定打补丁方式，关注各种漏洞信息，确认漏洞后调查补丁状况以及防范对策，并制定对应计划）</li><li>对不需要对外公开的端口或者服务加以访问限制（通过端口扫描确认各端口服务状态）</li><li>提高认证强度</li></ol><h3 id="怎么发现有没有被攻击"><a href="#怎么发现有没有被攻击" class="headerlink" title="怎么发现有没有被攻击"></a>怎么发现有没有被攻击</h3><p>攻击判断可以建立在设备的基础上，利用设备的告警，如果没有设备的话可以参考以下</p><p>网站被攻击：网站被跳转到赌博网站，网站首页被篡改，百度快照被改，网站被植入 webshell 脚本木马，网站被 DDOS、CC 压力攻击</p><p>服务器被黑：服务器系统中木马病毒，服务器管理员账号密码被改，服务器被攻击者远程控制，服务器的带宽向外发包，服务器被流量攻击，ARP攻击（目前这种比较少了，现在都是基于阿里云，百度云，腾讯云等云服务器）</p><p>对登录记录、系统日志、web 日志等进行分析</p><h2 id="⬆️细节题"><a href="#⬆️细节题" class="headerlink" title="⬆️细节题"></a>⬆️细节题</h2><h3 id="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"><a href="#你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？" class="headerlink" title="你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？"></a>你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？</h3><p>用流量监测的安全设备，比如天眼，查看报文，分析报文里和 host 和网站目录路径，查看是否可疑，使用微步查询 host 是否为恶意，使用 wireshark 对数据包深度分析</p><p>看一下请求的网站路径，源 IP 与目的 IP 地址，host 字段的值以及发包内容等</p><p>工具有 wireshark，网站的话微步在线等威胁情报中心</p><h3 id="文件上传和命令执行，有看过相关日志吗"><a href="#文件上传和命令执行，有看过相关日志吗" class="headerlink" title="文件上传和命令执行，有看过相关日志吗"></a>文件上传和命令执行，有看过相关日志吗</h3><p>文件：可能在系统有上传功能或者有文本编辑器，看一下是否有 base64 加密或者 url 加密，解码验证一下是否有恶意代码</p><p>系统日志：有没有 web 容器做了一些危险行为，比如 bash 反弹 shell 等</p><p>网络应用日志：有没有异常的网站文件，类似 webshell 等，<strong>就有可能是命令执行</strong></p><h3 id="windows日志分析工具"><a href="#windows日志分析工具" class="headerlink" title="windows日志分析工具"></a>windows日志分析工具</h3><p>Log Parser、LogParser Lizard、Event Log Explorer</p><h3 id="Linux日志分析技巧命令"><a href="#Linux日志分析技巧命令" class="headerlink" title="Linux日志分析技巧命令"></a>Linux日志分析技巧命令</h3><ol><li><p>定位有多少IP在爆破主机的root帐号：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"Failed password for root"</span> /var/log/secure <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $11}'</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -nr <span class="token operator">|</span> <span class="token function">more</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>定位有哪些IP在爆破：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"Failed password"</span> /var/log/secure<span class="token operator">|</span><span class="token function">grep</span> -E -o <span class="token string">"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"</span><span class="token operator">|</span><span class="token function">uniq</span> -c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>爆破用户名字典是什么？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"Failed password"</span> /var/log/secure<span class="token operator">|</span>perl -e <span class="token string">'while($_=&lt;&gt;){ /for(.*?) from/; print"$1\n";}'</span><span class="token operator">|</span><span class="token function">uniq</span> -c<span class="token operator">|</span><span class="token function">sort</span> -nr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>登录成功的IP有哪些</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token string">"Accepted "</span> /var/log/secure <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $11}'</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span> -c <span class="token operator">|</span> <span class="token function">sort</span> -nr <span class="token operator">|</span> <span class="token function">more</span>登录成功的日期、用户名、IP：<span class="token function">grep</span> <span class="token string">"Accepted "</span> /var/log/secure <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1,$2,$3,$9,$11}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>增加一个用户kali日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Jul <span class="token number">10</span> 00:12:15 localhost useradd<span class="token punctuation">[</span><span class="token number">2382</span><span class="token punctuation">]</span>: new group: <span class="token assign-left variable">name</span><span class="token operator">=</span>kali, <span class="token assign-left variable">GID</span><span class="token operator">=</span><span class="token number">1001</span>Jul <span class="token number">10</span> 00:12:15 localhost useradd<span class="token punctuation">[</span><span class="token number">2382</span><span class="token punctuation">]</span>: new user: <span class="token assign-left variable">name</span><span class="token operator">=</span>kali, <span class="token assign-left variable"><span class="token environment constant">UID</span></span><span class="token operator">=</span><span class="token number">1001</span>, <span class="token assign-left variable">GID</span><span class="token operator">=</span><span class="token number">1001</span>,<span class="token assign-left variable">home</span><span class="token operator">=</span>/home/kali, <span class="token assign-left variable">shell</span><span class="token operator">=</span>/bin/bashJul <span class="token number">10</span> 00:12:58 localhost passwd: pam_unix<span class="token punctuation">(</span>passwd:chauthtok<span class="token punctuation">)</span>: password changed <span class="token keyword">for</span> kali<span class="token comment">#grep "useradd" /var/log/secure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除用户kali日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Jul <span class="token number">10</span> 00:14:17 localhost userdel<span class="token punctuation">[</span><span class="token number">2393</span><span class="token punctuation">]</span>: delete user <span class="token string">'kali'</span>Jul <span class="token number">10</span> 00:14:17 localhost userdel<span class="token punctuation">[</span><span class="token number">2393</span><span class="token punctuation">]</span>: removed group <span class="token string">'kali'</span> owned by <span class="token string">'kali'</span>Jul <span class="token number">10</span> 00:14:17 localhost userdel<span class="token punctuation">[</span><span class="token number">2393</span><span class="token punctuation">]</span>: removed shadow group <span class="token string">'kali'</span> owned by <span class="token string">'kali'</span><span class="token comment"># grep "userdel" /var/log/secure</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>su切换用户：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Jul <span class="token number">10</span> 00:38:13 localhost su: pam_unix<span class="token punctuation">(</span>su-l:session<span class="token punctuation">)</span>: session opened <span class="token keyword">for</span> user good byroot<span class="token punctuation">(</span>uid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>sudo授权执行:<span class="token function">sudo</span> -lJul <span class="token number">10</span> 00:43:09 localhost sudo: good <span class="token builtin class-name">:</span> <span class="token assign-left variable">TTY</span><span class="token operator">=</span>pts/4 <span class="token punctuation">;</span> <span class="token assign-left variable"><span class="token environment constant">PWD</span></span><span class="token operator">=</span>/home/good <span class="token punctuation">;</span> <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span>root <span class="token punctuation">;</span><span class="token assign-left variable">COMMAND</span><span class="token operator">=</span>/sbin/shutdown -r now<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="给你一个比较大的日志，应该如何分析"><a href="#给你一个比较大的日志，应该如何分析" class="headerlink" title="给你一个比较大的日志，应该如何分析"></a>给你一个比较大的日志，应该如何分析</h3><ul><li>攻击规则匹配，通过正则匹配日志中的攻击请求</li><li>统计方法，统计请求出现次数，次数少于同类请求平均次数则为异常请求</li><li>白名单模式，为正常请求建立白名单，不在名单范围内则为异常请求</li><li>HMM 模型，类似于白名单，不同点在于可对正常请求自动化建立模型，从而通过正常模型找出不匹配者则为异常请求</li><li>借助日志分析工具，如 LogForensics 腾讯实验室 <a class="link" href="https://security.tencent.com/index.php/opensource/detail/15">https://security.tencent.com/index.php/opensource/detail/15 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h3 id="Windows在应急响应中的安全日志以及对应场景"><a href="#Windows在应急响应中的安全日志以及对应场景" class="headerlink" title="Windows在应急响应中的安全日志以及对应场景"></a>Windows在应急响应中的安全日志以及对应场景</h3><h3 id="设备误报如何处理"><a href="#设备误报如何处理" class="headerlink" title="设备误报如何处理"></a>设备误报如何处理</h3><p>（日志）</p><h3 id="Windows和Linux的日志文件放在哪里"><a href="#Windows和Linux的日志文件放在哪里" class="headerlink" title="Windows和Linux的日志文件放在哪里"></a>Windows和Linux的日志文件放在哪里</h3><ul><li><p>Windows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志</p><p>系统日志：<code> %SystemRoot%\System32\Winevt\Logs\System.evtx</code></p><p>应用程序日志：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></p><p>安全日志：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></p></li><li><p>Linux</p><p>日志默认存放位置：<code>/var/log/</code><br>查看日志配置情况：more /etc/rsyslog.conf</p></li></ul><h3 id="常见中间件的配置文件路径"><a href="#常见中间件的配置文件路径" class="headerlink" title="常见中间件的配置文件路径"></a>常见中间件的配置文件路径</h3><ul><li>apache：<code>/etc/httpd/conf</code></li><li>nginx：<code>/etc/nginx</code></li><li>iis7：<code>C:\Windows\System32\inetsrv\config\</code></li></ul><h3 id="如何查看系统内存-shell"><a href="#如何查看系统内存-shell" class="headerlink" title="如何查看系统内存 shell"></a>如何查看系统内存 shell</h3><ul><li>文章汇总：<a class="link" href="https://blog.csdn.net/shuteer_xu/article/details/117458250">link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>查杀内存马：<a class="link" href="https://gv7.me/articles/2020/kill-java-web-filter-memshell/">link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>php、python、java内存马分析：<a class="link" href="https://www.geekby.site/2021/09/webshell%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/">link <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h3 id="Java-内存马排查"><a href="#Java-内存马排查" class="headerlink" title="Java 内存马排查"></a>Java 内存马排查</h3><p><a class="link" href="https://www.freebuf.com/articles/web/274466.html">https://www.freebuf.com/articles/web/274466.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>如果我们通过检测工具或者其他手段发现了一些内存webshell的痕迹，需要有一个排查的思路来进行跟踪分析，也是根据各类型的原理，列出一个排查思路。</p><blockquote><p>如果是jsp注入，日志中排查可疑jsp的访问请求。</p><p>如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法</p><p>根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</p><p>如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。</p><p>如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200</p></blockquote><h3 id="如何修改WEB端口？如果不能修改端口还有什么利用方法？"><a href="#如何修改WEB端口？如果不能修改端口还有什么利用方法？" class="headerlink" title="如何修改WEB端口？如果不能修改端口还有什么利用方法？"></a>如何修改WEB端口？如果不能修改端口还有什么利用方法？</h3><p>修改 web 端口：修改中间件配置文件中的 web 服务端口即可</p><p>不能修改的话可以使用端口映射，使用 nginx 反向代理也可以</p><h3 id="获得文件读取漏洞，通常会读哪些文件，Linux和windows都谈谈"><a href="#获得文件读取漏洞，通常会读哪些文件，Linux和windows都谈谈" class="headerlink" title="获得文件读取漏洞，通常会读哪些文件，Linux和windows都谈谈"></a>获得文件读取漏洞，通常会读哪些文件，Linux和windows都谈谈</h3><p><strong>通用</strong></p><ul><li>找 Web 应用的配置文件，指不定有外联数据库</li><li>找 Web 中间件的配置文件，指不定有 Tomcat 配置界面的用户密码</li><li>找系统文件</li></ul><p><strong>linux</strong></p><ul><li><p><code>etc/passwd、etc/shadow</code>直接读密码</p></li><li><p><code>/etc/hosts</code> # 主机信息</p></li><li><p><code>/root/.bashrc</code> # 环境变量</p></li><li><p><code>/root/.bash_history</code> # 还有root外的其他用户</p></li><li><p><code>/root/.viminfo</code> # vim 信息</p></li><li><p><code>/root/.ssh/id_rsa</code> # 拿私钥直接ssh</p></li><li><p><code>/proc/xxxx/cmdline</code> # 进程状态枚举 xxxx 可以为0000-9999 使用burpsuite</p></li><li><p>数据库 config 文件</p></li><li><p>web 日志 <code>access.log, error.log</code></p></li><li><p>ssh 日志</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/root/.ssh/id_rsa/root/.ssh/id_rsa.pub/root/.ssh/authorized_keys/etc/ssh/sshd_config/var/log/secure/etc/sysconfig/network-scripts/ifcfg-eth0/etc/syscomfig/network-scripts/ifcfg-eth1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>/var/lib/php/sess_PHPSESSID</code> # 非常规问题 session 文件( 参考 平安科技的一道session包含 <a class="link" href="http://www.jianshu.com/p/2c24ea34566b">http://www.jianshu.com/p/2c24ea34566b <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</p></li></ul><p><strong>windows</strong></p><ul><li><code>C:\boot.ini</code> //查看系统版本</li><li><code>C:\Windows\System32\inetsrv\MetaBase.xml</code> //IIS 配置文件</li><li><code>C:\Windows\repair\sam</code> //存储系统初次安装的密码</li><li><code>C:\Program Files\mysql\my.ini</code> //Mysql 配置</li><li><code>C:\Program Files\mysql\data\mysql\user.MY D</code> //Mysql root</li><li><code>C:\Windows\php.ini</code> //php 配置信息</li><li><code>C:\Windows\my.ini</code> //Mysql 配置信息</li></ul><h3 id="如何分析被代理出来的数据流"><a href="#如何分析被代理出来的数据流" class="headerlink" title="如何分析被代理出来的数据流"></a>如何分析被代理出来的数据流</h3><p>分析数据包请求头中的 xff、referer 等收集有用的信息</p><p><a class="link" href="https://www.freebuf.com/articles/web/245585.html">基于网络欺骗与浏览器指纹的WEB攻击溯源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="windows端口进程间转换"><a href="#windows端口进程间转换" class="headerlink" title="windows端口进程间转换"></a>windows端口进程间转换</h3><p>端口-&gt;进程</p><ol><li><code>netstat -ano | findstr “port”</code>查看目前的网络连接，定位可疑的 ESTABLISHED</li><li>根据<code>netstat </code>定位出的 pid，再通过<code>tasklist</code>命令进行进程定位<code> tasklist | findstr “PID”</code></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/NVM7Jl4bv8sqyiK.png" alt="image-20220103194348302"></p><h3 id="查看进程对应的程序位置"><a href="#查看进程对应的程序位置" class="headerlink" title="查看进程对应的程序位置"></a>查看进程对应的程序位置</h3><p>任务管理器–选择对应进程–右键打开文件位置运行输入 wmic，cmd界面 输入 process</p><p>查看 Windows 服务所对应的端口</p><p><code>%system%/system32/drivers/etc/services</code>（一般 %system% 就是 C:\Windows）</p><h3 id="查看windows进程的方法"><a href="#查看windows进程的方法" class="headerlink" title="查看windows进程的方法"></a>查看windows进程的方法</h3><ol><li>开始 – 运行 – 输入<code>msinfo32</code> 命令，依次点击 “软件环境 – 正在运行任务” 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等</li><li>打开D盾_web查杀工具，进程查看，关注没有签名信息的进程</li><li>通过微软官方提供的 Process Explorer 等工具进行排查</li></ol><p>查看<strong>可疑的进程</strong>及其子进程。可以通过观察以下内容：</p><ul><li>没有签名验证信息的进程</li><li>没有描述信息的进程</li><li>进程的属主</li><li>进程的路径是否合法</li><li>CPU 或内存资源占用长时间过高的进程</li></ul><h3 id="你能说明文件上传的原理吗？"><a href="#你能说明文件上传的原理吗？" class="headerlink" title="你能说明文件上传的原理吗？"></a>你能说明文件上传的原理吗？</h3><ul><li>PHP：如果系统中存在可以上传文件的功能点，就可以上传后门脚本文件，通过一些方法绕过上传限制，如果能访问后门的的话，系统存在文件上传漏洞，可以借助后门执行命令</li><li>Java：上传 jsp 代码</li><li>Asp/Aspx</li><li>Python：因为脚本需要译后生成 pyc 字节码文件，所以不存在文件上传</li></ul><h3 id="文件上传攻击特征？"><a href="#文件上传攻击特征？" class="headerlink" title="文件上传攻击特征？"></a>文件上传攻击特征？</h3><p>能够上传文件的接口，应用程序对用户上传文件类型不校验或者校验不严格可绕过，导致任意类型文件上传，攻击者可上传 webshell 拿到服务器权限，在这个过程中攻击者必然会上传恶意脚本文件</p><h3 id="文件上传加固方法？"><a href="#文件上传加固方法？" class="headerlink" title="文件上传加固方法？"></a>文件上传加固方法？</h3><ol><li>后端限制文件上传白名单，头像不允许上传 svg</li><li>上传后文件随机重命名，不要输出保存文件位置</li><li>图片文件可以二次渲染，使用对象存储 oss</li><li>文件目录取消执行权限，PHP 设置 basedir</li></ol><h3 id="用过Nmap扫描工具吗"><a href="#用过Nmap扫描工具吗" class="headerlink" title="用过Nmap扫描工具吗"></a>用过Nmap扫描工具吗</h3><p>nmap 扫描基础命令</p><ul><li>-sT TCP (全)连接扫描，准确但留下大量日志记录</li><li>-sS TCP SYN (半)扫描，速度较快，不会留下日志</li><li>-sN null 扫描，标志位全为 0，不适用 Windows</li><li>-sF FIN 扫描，标志位 FIN=1，不适用 Windows</li><li>-O 查看目标主机系统版本</li><li>-sV 探测服务版本</li><li>-A 全面扫描</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/rdcNnQ5zoyEqHhK.png" alt="img"></p><h3 id="你做过渗透测试的工作吗？"><a href="#你做过渗透测试的工作吗？" class="headerlink" title="你做过渗透测试的工作吗？"></a>你做过渗透测试的工作吗？</h3><p>首先信息收集，收集子域名、Whois、C段、旁站、Web 系统指纹识别，然后测试 web 系统的漏洞</p><h3 id="暴力破解加固方法？"><a href="#暴力破解加固方法？" class="headerlink" title="暴力破解加固方法？"></a>暴力破解加固方法？</h3><ol><li>添加强度较高的验证码，不易被破解</li><li>修改密码设置规则，提高用户的密码强度</li><li>同一账号登陆次数锁定，生成锁定日志</li><li>定期排查弱口令</li></ol><h3 id="Sql注入加固措施？"><a href="#Sql注入加固措施？" class="headerlink" title="Sql注入加固措施？"></a>Sql注入加固措施？</h3><p>对于输入的字符进行过滤</p><p>使用 PDO 预编译语句处理</p><h3 id="一台主机在内网进行横向攻击，你应该怎么做？"><a href="#一台主机在内网进行横向攻击，你应该怎么做？" class="headerlink" title="一台主机在内网进行横向攻击，你应该怎么做？"></a>一台主机在内网进行横向攻击，你应该怎么做？</h3><p>确定攻击来源，是不是员工内部误操作，比如询问运维是否有自动化轮训脚本</p><p>如果没有，确定是攻击，结合时间点，根据设备信息，看一下安全事件，进程，流量</p><p>找到问题主机，开始应急响应流程：准备、检测、遏制、根除、恢复、跟踪，具体的操作要交给现场运维去处理</p><h3 id="你还用过其他态势感知的产品吗？"><a href="#你还用过其他态势感知的产品吗？" class="headerlink" title="你还用过其他态势感知的产品吗？"></a>你还用过其他态势感知的产品吗？</h3><p>ips，ids，hids，堡垒机等</p><h3 id="命令行工具用的什么比较多？"><a href="#命令行工具用的什么比较多？" class="headerlink" title="命令行工具用的什么比较多？"></a>命令行工具用的什么比较多？</h3><p>xshell、xftp、finalshell</p><h3 id="你用过微步吗？"><a href="#你用过微步吗？" class="headerlink" title="你用过微步吗？"></a>你用过微步吗？</h3><p>微步在线是一个威胁情报中心，可以通过 ip 或域名查询其是不是恶意的，对于判断恶意链接具有一定的参考性，他还有一个插件可以在页面选中就能进行查询，还是一个比较好用的工具</p><h3 id="什么是跨域，JSONP与CORS"><a href="#什么是跨域，JSONP与CORS" class="headerlink" title="什么是跨域，JSONP与CORS"></a>什么是跨域，JSONP与CORS</h3><p><strong>同源策略</strong></p><p>同源策略：域名、协议、端口均相同</p><p>浏览器执行 JavaScript 脚本时，会检查这个脚本属于那个页面，如果不是同源页面，就不会被执行</p><p><strong>什么是跨域？</strong></p><p>跨域：指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器的安全限制！</p><p><strong>JSONP跨域</strong></p><p>利用 js script 标签中 src 属性可以跨域的特性，使用 callback 参数的函数名来接收数据</p><p>只支持 GET 请求，不支持 POST 等其它请求，也不支持复杂请求，只支持简单请求</p><p><strong>CORS跨域</strong></p><p>支持所有的请求，包含 GET、POST、OPTOIN、PUT、DELETE 等既支持复杂请求，也支持简单请求</p><p>JSONP 与 CORS 的使用目的相同，并且都需要服务端和客户端同时支持，但 CORS 的功能更加强大</p><p><strong>JSONP和CORS的优缺点</strong></p><ol><li>JSONP 的主要优势在于对浏览器的支持较好；虽然目前主流浏览器都支持 CORS，但 IE9 及以下不支持 CORS</li><li>JSONP 只能用于获取资源（即只读，类似于 GET 请求）；CORS 支持所有类型的 HTTP 请求，功能完善</li><li>JSONP 只会发一次请求；而对于复杂请求，CORS 会发两次请求</li></ol><p><strong>应用场景</strong></p><p>如果需要兼容IE低版本浏览器，无疑，JSONP</p><p>如果需要对服务端资源进行操作，无疑，CORS</p><p>其他情况的话，根据自己的对需求的分析来决定和使用</p><h3 id="http状态与无连接"><a href="#http状态与无连接" class="headerlink" title="http状态与无连接"></a>http状态与无连接</h3><p><strong>无连接</strong></p><ol><li>每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的</li><li>无连接的含义是限制每次连接只处理一个请求服务器处理完客户的请求，并收到客户的应答后，即断开连接</li></ol><p><strong>无状态</strong></p><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个 url 请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li></ol><h3 id="什么是路由表"><a href="#什么是路由表" class="headerlink" title="什么是路由表"></a>什么是路由表</h3><p>在计算机网络中，路由表（routing table）或称路由择域信息库（RIB, Routing Information Base），是一个存储在路由器或者联网计算机中的电子表格（文件）或类数据库路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）路由表中含有网络周边的拓扑信息路由表建立的主要目标是为了实现路由协议和静态路由选择</p><p>每个路由器中都有一个路由表和 FIB(Forward Information Base) 表：路由表用来决策路由，FIB 用来转发分组路由表中有三类路由：</p><ol><li>链路层协议发现的路由（即是直连路由）</li><li>静态路由</li><li>动态路由协议 RIP、OSRF 发现的路由</li></ol><h3 id="非sql数据库"><a href="#非sql数据库" class="headerlink" title="非sql数据库"></a>非sql数据库</h3><p>Zookeeper，HBase、Redis、MongoDB、Couchbase、LevelDB</p><h3 id="常见OA系统"><a href="#常见OA系统" class="headerlink" title="常见OA系统"></a>常见OA系统</h3><p>PHP：通达OA、泛微 Eoffice</p><p>Java：泛微OA/云桥、致远OA、蓝凌OA、用友OA</p><p>ASP：启莱OA</p><h3 id="横向越权漏洞的修复"><a href="#横向越权漏洞的修复" class="headerlink" title="横向越权漏洞的修复"></a>横向越权漏洞的修复</h3><p>横向越权：横向越权指的是攻击者尝试访问与他拥有相同权限的用户的资源</p><p>纵向越权：纵向越权指的是一个低级别攻击者尝试访问高级别用户的资源</p><p>对于纵向越权，我们可以通过设置用户角色，为不同的角色提供不同的权限来避免</p><p>为了防止横向越权，我们可以使用缓存来进行辅助，当登录成功或者进行操作时，我们在缓存中存储一对由用户名和一个唯一的数字组成的数据（token），然后返回放入的唯一数据在重置密码时我们的参数不仅需要用户名和密码还需要前面生成的唯一数字，根据用户名在缓存中取出对应的数字，如果取出的数字和参数中传入的想等，则证明重置的当前用户的密码，否则不是，且不予以重置</p><h3 id="如何打击黑灰产工具"><a href="#如何打击黑灰产工具" class="headerlink" title="如何打击黑灰产工具"></a>如何打击黑灰产工具</h3><ol><li>全面监控和快速响应（溯源）：对黑灰进行长期跟进，了解黑灰产工具的传播链条和路径，第一时间捕获活跃的黑灰产工具（建立特征词监控，数据取样、交叉分析）</li><li>建立软件指纹库，增加风险识别能力</li><li>建立黑灰产情报共享，最大化情报价值</li></ol><h3 id="如何反爬"><a href="#如何反爬" class="headerlink" title="如何反爬"></a>如何反爬</h3><ol><li>后台对访问进行统计，如果单个 IP 访问超过阈值，予以封锁</li><li>后台对访问进行统计，如果单个 session 访问超过阈值，予以封锁</li><li>后台对访问进行统计，如果单个 userAgent 访问超过阈值，予以封锁</li><li>以上的组合</li></ol><h3 id="Linux下查找服务端口的命令"><a href="#Linux下查找服务端口的命令" class="headerlink" title="Linux下查找服务端口的命令"></a>Linux下查找服务端口的命令</h3><p>Linux下查找服务端口的命令？一句话查找80端口服务的命令？</p><p>使用grep 命令 要使用 grep 命令在Linux 中查找指定服务的默认端口号，只需运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> /etc/services<span class="token function">grep</span> services /etc/services<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/qZVnLyhwU1mDdXs.png" alt="image-20220107203438844"></p><h3 id="如何发现钓鱼邮件"><a href="#如何发现钓鱼邮件" class="headerlink" title="如何发现钓鱼邮件"></a>如何发现钓鱼邮件</h3><p><strong>钓鱼邮件发现</strong></p><p>发现途径如下：</p><p>邮件系统异常登录告警、员工上报、异常行为告警、邮件蜜饵告警</p><p>推荐接入微步或奇安信的情报数据。对邮件内容出现的 URL 做扫描，可以发现大量的异常链接</p><h3 id="钓鱼邮件处置"><a href="#钓鱼邮件处置" class="headerlink" title="钓鱼邮件处置"></a>钓鱼邮件处置</h3><p><a class="link" href="https://www.freebuf.com/articles/es/264037.html">https://www.freebuf.com/articles/es/264037.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol><li><p>屏蔽办公区域对钓鱼邮件内容涉及站点、URL 访问</p><p>根据办公环境实际情况可以在上网行为管理、路由器、交换机上进行屏蔽</p><p>邮件内容涉及域名、IP 均都应该进行屏蔽</p><p>对访问钓鱼网站的内网 IP 进行记录，以便后续排查溯源可能的后果</p></li><li><p>屏蔽钓鱼邮件</p><p>屏蔽钓鱼邮件来源邮箱域名</p><p>屏蔽钓鱼邮件来源 IP</p><p>有条件的可以根据邮件内容进行屏蔽</p><p>删除还在邮件服务器未被客户端收取钓鱼邮件</p></li><li><p>处理接收到钓鱼邮件的用户</p><ul><li><p>根据钓鱼邮件发件人进行日志回溯</p><p>此处除了需要排查有多少人接收到钓鱼邮件之外，还需要排查是否公司通讯录泄露。采用 TOP500 姓氏撞库发送钓鱼邮件的攻击方式相对后续防护较为简单。如果发现是使用公司通讯录顺序则需要根据通讯录的离职情况及新加入员工排查通讯录泄露时间。毕竟有针对性的社工库攻击威力要比 TOP100、TOP500 大很多</p></li><li><p>通知已接收钓鱼邮件的用户进行处理</p></li><li><p><strong>删除钓鱼邮件</strong></p></li><li><p><strong>系统改密</strong></p></li><li><p><strong>全盘扫毒</strong></p></li></ul></li><li><p>后续：溯源、员工培训提升安全意识</p></li></ol><h3 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h3><p>（扫描数据量大，请求有规律，手动扫描间隔较少）</p><h3 id="遇到-exe文件如何处理？"><a href="#遇到-exe文件如何处理？" class="headerlink" title="遇到.exe文件如何处理？"></a>遇到.exe文件如何处理？</h3><p>首先看它的来源和去向，然后可以下载但不运行，放入微步沙箱中，看是否有后门，若有后门，就用 IDA 反汇编得到恶意攻击者的有用信息，再进一步描绘出攻击者画像进行溯源</p><h3 id="Linux-的-Selinux-是什么？如何设置-Selinux？"><a href="#Linux-的-Selinux-是什么？如何设置-Selinux？" class="headerlink" title="Linux 的 Selinux 是什么？如何设置 Selinux？"></a>Linux 的 Selinux 是什么？如何设置 Selinux？</h3><p>SELinux 是一种安全子系统，它能控制程序只能访问特定文件使用 setup 工具进入图形化关闭搜索或者修改<code>/etc/sysconfig/selinux</code> 文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">SELINUX</span><span class="token operator">=</span>disabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>防火墙打开使用 <code>service iptables start</code> 或则<code>/etc/init.d/iptables start</code></p><h3 id="iptables-工作在-TCP-x2F-IP-模型中的哪层？"><a href="#iptables-工作在-TCP-x2F-IP-模型中的哪层？" class="headerlink" title="iptables 工作在 TCP/IP 模型中的哪层？"></a>iptables 工作在 TCP/IP 模型中的哪层？</h3><p>网络层</p><h3 id="日志分析ELK的使用和分析"><a href="#日志分析ELK的使用和分析" class="headerlink" title="日志分析ELK的使用和分析"></a>日志分析ELK的使用和分析</h3><blockquote><p><a class="link" href="https://www.zhihu.com/question/21427267">https://www.zhihu.com/question/21427267 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</li><li>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li><li>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</li></ul></blockquote><p>举例-阿里规范 用户历史命令记录</p><p>缺点：安全性不够。使用x-pack实现安全认证及权限管理功能</p><h3 id="awk-sed的使用"><a href="#awk-sed的使用" class="headerlink" title="awk sed的使用"></a>awk sed的使用</h3><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>log4j 是 javaweb 的日志组件，用来记录 web 日志</p><p>去指定下载文件的 url 在搜索框或者搜索的 url 里面，加上 ${jndi:ldap://127.0.0.1/test} ，log4j 会对这串代码进行表达式解析，给 lookup 传递一个恶意的参数指定，参数指的是比如 ldap 不存在的资源 $ 是会被直接执行的。后面再去指定下载文件的 url，去下载我们的恶意文件。比如是 x.class 下载完成后，并且会执行代码块</p><p>修复：升级 Log4j 到最新版本，根据业务判断是否关闭 lookup</p><h2 id="⬆️入侵检测-amp-防御"><a href="#⬆️入侵检测-amp-防御" class="headerlink" title="⬆️入侵检测&amp;防御"></a>⬆️入侵检测&amp;防御</h2><h3 id="WAF产品如何来拦截攻击？"><a href="#WAF产品如何来拦截攻击？" class="headerlink" title="WAF产品如何来拦截攻击？"></a>WAF产品如何来拦截攻击？</h3><p>Waf 产品有三种</p><ol><li><p>云 Waf</p><p>用户不需要在自己的网络中安装软件程序或部署硬件设备，就可以对网站实施安全防护，它的主要实现方式是<strong>利用 DNS 技术</strong>，通过移交域名解析权来实现安全防护。用户的请求首先发送到云端节点进行检测，如存在异常请求则进行拦截否则将请求转发至真实服务器</p></li><li><p>Web 防护软件</p><p>安装在需要防护的服务器上，实现方式通常是 <strong>Waf 监听端口或以 Web 容器扩展</strong>方式进行请求检测和阻断</p></li><li><p>硬件 Web 防火墙</p><p>Waf <strong>串行部署</strong>在 Web 服务器前端，用于检测、阻断异常流量。常规硬件 Waf 的实现方式是通过<strong>代理技术</strong>代理来自外部的流量</p></li></ol><p>原理都相同，通过部署在 Web 服务器前方串行接入来将 Web 流量牵引到 WAF 设备中进行清洗或者拦截，最终只把正常用户的请求转发给服务器</p><p>当前市场上 Waf 产品核心的防护机制是“规则”，每一个请求、会话，经过抓包，“开包检查”，每一项规则都会检查到，一旦检查不通过，就会被认为是非法访问，拒绝处理</p><h3 id="WAF有哪些防护方式？"><a href="#WAF有哪些防护方式？" class="headerlink" title="WAF有哪些防护方式？"></a>WAF有哪些防护方式？</h3><ul><li><p>Web基础防护</p><p>可防范常规的 web 应用攻击，如 SQL 注入攻击、XSS 跨站攻击等，可检测 webshell，检查 HTTP 上传通道中的网页木马，打开开关即实时生效</p></li><li><p>CC 攻击防护</p><p>可根据 IP、Cookie 或者 Referer 字段名设置灵活的限速策略，有效缓解 CC 攻击</p></li><li><p>精准访问防护</p><p>对常见 HTTP 字段进行条件组合， 支持定制化防护策略如CSRF防护，通过自定义规则的配置，更精准的识别恶意伪造请求、保护网站敏感信息、提高防护精准性</p></li><li><p>IP 黑白名单</p><p>添加终拦截与始终放行的黑白名单 IP，增加防御准确性</p></li><li><p>地理位置访问控制</p><p>添加地理位置访问控制规则，针对来源 IP 进行自定义访问控制</p></li><li><p>网页防篡改</p><p>对网站的静态网页进行缓存配置，当用户访问时返回给用户缓存的正常页面，并随机检测网页是否被篡改</p></li><li><p>网站反爬虫</p><p>动态分析网站业务模型，结合人机识别技术和数据风控手段，精准识别爬虫行为</p></li><li><p>误报屏蔽</p><p>针对特定请求忽略某些攻击检测规则，用于处理误报事件</p></li><li><p>隐私屏蔽</p><p>隐私信息屏蔽，避免用户的密码等信息出现在事件日志中</p></li><li><p>防敏感信息泄露</p><p>防止在页面中泄露用户的敏感信息，例如：用户的身份证号码、手机号码、电子邮箱等</p></li></ul><h3 id="不安全的第三方组件的漏洞如何做前置规避？"><a href="#不安全的第三方组件的漏洞如何做前置规避？" class="headerlink" title="不安全的第三方组件的漏洞如何做前置规避？"></a>不安全的第三方组件的漏洞如何做前置规避？</h3><p>第三方组件缺陷又被归结为供应链安全问题，供应链安全需要多方面考虑。没有万能方案，但是组织可以用分层防御的组合来保护供应链</p><ul><li><p>安全战略评估</p><p>要评估风险与合规性，需要针对业务挑战、需求和目标评估现有的安全治理框架——包括数据隐私、第三方风险和IT法规合规需求及差距。安全风险量化、安全开发、法规和标准合规性以及安全教育和培训是关键</p></li><li><p>事件响应计划与编排</p><p>提前为入侵、关闭或中断做好准备，并拥有稳健的事件响应计划很重要。通过实践、测试和易执行的响应计划和补救措施，防止损失</p></li></ul><p><a class="link" href="https://www.freebuf.com/articles/neopoints/261681.html">https://www.freebuf.com/articles/neopoints/261681.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="如果现在要你写一个检测命令注入的脚本？"><a href="#如果现在要你写一个检测命令注入的脚本？" class="headerlink" title="如果现在要你写一个检测命令注入的脚本？"></a>如果现在要你写一个检测命令注入的脚本？</h3><p>你会怎么写，有哪些要注意的地方，如果别人的脚本检测出来了你的脚本没检测出来你觉的你的脚本会存在什么问题，脚本检测过程中如果没有回显你会怎么做</p><h1 id="🅰️溯源"><a href="#🅰️溯源" class="headerlink" title="🅰️溯源"></a>🅰️溯源</h1><p><img lazyload="" src="/images/loading.svg" data-src="https://s2.loli.net/2022/05/25/2ZAenxgQsu6b7DC.png" alt="image-20220103203355953"></p><h2 id="⬆️基本步骤"><a href="#⬆️基本步骤" class="headerlink" title="⬆️基本步骤"></a>⬆️基本步骤</h2><h3 id="1-攻击源捕获"><a href="#1-攻击源捕获" class="headerlink" title="1.攻击源捕获"></a>1.攻击源捕获</h3><ul><li>安全设备报警，如扫描IP、威胁阻断、病毒木马、入侵事件等</li><li>日志与流量分析，异常的通讯流量、攻击源与攻击目标等</li><li>服务器资源异常，异常的文件、账号、进程、端口，启动项、计划任务和服务等</li><li>邮件钓鱼，获取恶意文件样本、钓鱼网站 URL 等</li><li>蜜罐系统，获取攻击者 ID、电脑信息、浏览器指纹、行为、意图的相关信息</li></ul><h3 id="2-溯源反制手段"><a href="#2-溯源反制手段" class="headerlink" title="2.溯源反制手段"></a>2.溯源反制手段</h3><ul><li>IP 定位技术<br>根据IP定位物理地址–代理 IP<br>溯源案例：通过 IP 端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息</li><li>ID 追踪术<br>ID 追踪术，搜索引擎、社交平台、技术论坛、社工库匹配<br>溯源案例：利用 ID 从技术论坛追溯邮箱，继续通过邮箱反追踪真实姓名，通过姓名找到相关简历信息</li><li>网站 url<br>域名 Whois 查询–注册人姓名、地址、电话和邮箱 –域名隐私保护<br>溯源案例：通过攻击 IP 历史解析记录/域名，对域名注册信息进行溯源分析</li><li>恶意样本分析<br>提取样本特征、用户名、ID、邮箱、C2 服务器等信息–同源分析<br>溯源案例：样本分析过程中，发现攻击者的个人 ID 和 QQ，成功定位到攻击者</li><li>社交账号<br>基于 JSONP 跨域，获取攻击者的主机信息、浏览器信息、真实 IP 及社交信息等<br>利用条件：可以找到相关社交网站的 jsonp 接口泄露敏感信息，相关网站登录未注销</li></ul><h3 id="3-攻击者画像"><a href="#3-攻击者画像" class="headerlink" title="3.攻击者画像"></a>3.攻击者画像</h3><ul><li><p>攻击路径</p><p>攻击目的：拿到权限、窃取数据、获取利益、DDOS 等<br>网络代理：代理 IP、跳板机、C2 服务器等<br>攻击手法：鱼叉式邮件钓鱼、Web渗透、水坑攻击、近源渗透、社会工程等</p></li><li><p>攻击者身份画像</p><p>虚拟身份：ID、昵称、网名<br>真实身份：姓名、物理位置<br>联系方式：手机号、qq/微信、邮箱<br>组织情况：单位名称、职位信息</p></li></ul><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li>域名、ip 反查目标个人信息</li><li>支付宝转账，确定目标姓氏</li><li>淘宝找回密码，确定目标名字</li><li>企业微信手机号查公司名称</li><li>REG007 查注册应用、网站</li><li>程序 PDB 信息泄露</li></ol><h3 id="主动防御"><a href="#主动防御" class="headerlink" title="主动防御"></a>主动防御</h3><p><a class="link" href="https://www.freebuf.com/articles/web/245585.html">基于网络欺骗与浏览器指纹的WEB攻击溯源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ol><li>浏览器指纹技术</li><li>网络欺骗技术，蜜罐蜜网</li></ol><h3 id="流量溯源"><a href="#流量溯源" class="headerlink" title="流量溯源"></a>流量溯源</h3><p>可利用流量工具 wireshark 进行溯源：</p><ol><li>查看 eval、 z0、 shell whoami 等关键字，查看出现次数过多的时候， 需要查看是哪个页面发起的请求，有可能是 webshell</li><li>通过 WireShark 工具快速搜索关键字，定位到异常流量包</li><li>找出异常 IP 和所上传的内容，查看是否为 webshell</li></ol><p>如何定位到攻击IP：</p><ol><li><p>首先通过选择 - 统计 - 对话查看流量的走向情况， 定位可疑的 IP 地址</p></li><li><p>根据定位到的 IP 地址，尝试对上传的 webshell 进行定位</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ip.addr <span class="token operator">==</span> <span class="token function">ip</span> <span class="token operator">&amp;&amp;</span> http matches<span class="token string">"uploadllevallselectlxp_cmdshell"</span> <span class="token operator">&amp;&amp;</span> http.request.method <span class="token operator">==</span> <span class="token string">"POST"</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查找到 webshell 后尝试溯源漏洞位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http.request.uri contains <span class="token string">"webshell.php"</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定位到最开始 webshell 执行或上传的时候</p></li><li><p>根据最开始的 HTTP 上传包或者其他漏洞特征定位漏洞类型</p></li></ol><h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><p>wireshark 简单的过滤规则</p><ul><li><p>过滤ip：</p><p>过滤源 ip 地址：ip.src1.1.1.1</p><p>目的 ip 地址：ip.dst1.1.1.1</p></li><li><p>过滤端口：</p><p>过滤80端口：tcp.port == 80</p><p>源端口：tcp.srcport == 80</p><p>目的端：tcp.dstport == 80</p></li><li><p>协议过滤：直接输入协议名即可，如 http 协议 http</p></li><li><p>http 模式过滤：过滤 get/post 包 httprequest.mothod == “GET/POST”</p></li></ul><h3 id="常用取证工具"><a href="#常用取证工具" class="headerlink" title="常用取证工具"></a>常用取证工具</h3><p>Wireshark、xplico、 Volatility、 FastlR Collector、Autopsy、 Dumplt、 FTK Imager、Foremost、Scalpel、 Bulk_ exetractor 等</p><h3 id="优秀文章"><a href="#优秀文章" class="headerlink" title="优秀文章"></a>优秀文章</h3><p><a class="link" href="https://www.anquanke.com/post/id/260888">域前置溯源方法思考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="⬆️其他"><a href="#⬆️其他" class="headerlink" title="⬆️其他"></a>⬆️其他</h2><h3 id="对蜜罐的了解"><a href="#对蜜罐的了解" class="headerlink" title="对蜜罐的了解"></a>对蜜罐的了解</h3>]]></content>
      
      
      <categories>
          
          <category> 知识整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 攻防 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
